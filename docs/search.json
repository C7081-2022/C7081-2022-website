[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Welcome to C7081. This module is a survey of machine learning and statistical methods including supervised and unsupervised classification, regression, and tree-based methods. There is an emphasis on practical applications using a series of data stories and lab exercises, along with lectures on selected topics and readings. A prerequisite is a basic working knowledge of R programming and introductory statistics."
  },
  {
    "objectID": "index.html#c7081-resources",
    "href": "index.html#c7081-resources",
    "title": "Home",
    "section": "C7081 Resources",
    "text": "C7081 Resources\n\nTextbook: James et al. 2021 Introduction to statistical learning 2ed\nSlack workspace (for enrolled students)\nOffice hours (Slack, Fridays by appointment)"
  },
  {
    "objectID": "index.html#harper-adams-data-science",
    "href": "index.html#harper-adams-data-science",
    "title": "Home",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab01.html#c7081-resources",
    "href": "lab01.html#c7081-resources",
    "title": "Lab 01 linear alg.",
    "section": "C7081 Resources",
    "text": "C7081 Resources"
  },
  {
    "objectID": "lab01.html#harper-adams-data-science",
    "href": "lab01.html#harper-adams-data-science",
    "title": "Lab 01 linear alg.",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "The material in this module is designed to be experienced in an intensive one week format followed by an assessment meant to showcase data science skills (e.g. a github project website that could be part of your cv). For enrolled students, the work will be supported with several live sessions during the main week of delivery.\n\n\n\n\nDay\nTopics\nLabs\nReadings\n\n\n\n\nInduction\n welcome activity \nLab welcome exercise\n\n\n\nMon\n*lecture videos password: data4life\n 00 Module overview\n 01 Introduction 1.1 1.2\n 02 Statistical learning 2.1 2.2\nLab guidance\nLab 01 Linear algebra fun\nLab 02 R programming refresh\nJames et al. 2021 Ch 1,2\nEfron 2020\n\n\nTues\n 03 Linear regression 3.1 3.2\n 04 Classification 4.1 4.2\nLab 03 Linear regression\nLab 04 Classification\nJames et al. 2021 Ch 3,4\nMelesse 2018\n\n\nWed\n 05 Bootstrapping 5.1 5.2\n 06 Model selection 6.1 6.2 6.3\nLab 05 Resampling\nLab 06 Model selection\nJames et al. 2021 Ch 5,6\nAho 2014\n\n\nThurs\n 07 Non-linear models7.1 7.2\n 08 Decision trees8.1 8.2 8.3 8.4\nLab 07 Non-linear models\nLab 08 Decision trees\nJames et al. 2021 Ch 7,8\nBarnard 2019\nOtukei 2010\n\n\nFri\n 09 Support vector machines 9.1 9.2\n 10 Unsupervised learning 10.1 10.2 10.3\nLab 09 SVM\nLab 10 Unsupervised learning\nJames et al. 2021 Ch 9,12\nEbrahimi 2017\nHowell 2020"
  },
  {
    "objectID": "schedule.html#references",
    "href": "schedule.html#references",
    "title": "Schedule",
    "section": "References",
    "text": "References\nTextbook: James et al. 2021 Introduction to statistical learning 2ed\nall refs zip\nAho, K., Derryberry, D., Peterson, T., 2014. Model selection for ecologists: the worldviews of AIC and BIC. Ecology 95, 631–636.\nBarnard, D.M., Germino, M.J., Pilliod, D.S., Arkle, R.S., Applestein, C., Davidson, B.E., Fisk, M.R., 2019. Cannot see the random forest for the decision trees: selecting predictive models for restoration ecology. Restoration Ecology 27, 1053–1063.\nEbrahimi, M.A., Khoshtaghaza, M.H., Minaei, S., Jamshidi, B., 2017. Vision-based pest detection based on SVM classification method. Computers and Electronics in Agriculture 137, 52–58.\nEfron, B., 2020. Prediction, Estimation, and Attribution. Journal of the American Statistical Association 115, 636–655.\nHowell, O., Wenping, C., Marsland, R., Mehta, P., 2020. Machine learning as ecology. J. Phys. A: Math. Theor. 53, 334001.\nJames, G., Witten, D., Hastie, T., Tibshirani, R., 2021. An Introduction to Statistical Learning: with Applications in R, Springer Texts in Statistics 2ed. Springer-Verlag, New York.\nMelesse, S., Sobratee, N., Workneh, T., 2016. Application of logistic regression statistical technique to evaluate tomato quality subjected to different pre- and post-harvest treatments. Biological Agriculture & Horticulture 32, 277–287.\nOtukei, J.R., Blaschke, T., 2010. Land cover change assessment using decision trees, support vector machines and maximum likelihood classification algorithms. International Journal of Applied Earth Observation and Geoinformation, Supplement Issue on “Remote Sensing for Africa – A Special Collection from the African Association for Remote Sensing of the Environment (AARSE)” 12, S27–S31."
  },
  {
    "objectID": "schedule.html#harper-adams-data-science",
    "href": "schedule.html#harper-adams-data-science",
    "title": "Schedule",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab00-guidance.html",
    "href": "lab00-guidance.html",
    "title": "Lab Guidance",
    "section": "",
    "text": "There are several recommendations you should follow to get the most out of these exercises and this module as a whole.\n\nSet up a separate script for each lab (e.g. an R script) to organize and document your work\nAnswer each question formally and fully\nUse a fully commented, reproducible script style with a Header, Contents, and clickable Section blocks. This will help you practice Best Practice (see what I did there?), and will make the script useful to yourself in the future as a reference (e.g., the next time you want to set up a K means analysis script…)\nType 100% of your own code: do not copy and paste anything (practice, practice + troubleshooting error messages for typos and other issues)\nConsider writing your lab scripts using R Markdown\nConsider setting up a Github repository for your lab scripts"
  },
  {
    "objectID": "lab00-guidance.html#harper-adams-data-science",
    "href": "lab00-guidance.html#harper-adams-data-science",
    "title": "Lab Guidance",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab01-lin-alg.html",
    "href": "lab01-lin-alg.html",
    "title": "Lab 01 Linear alg.",
    "section": "",
    "text": "Linear algebra is the (math) foundation of statistics and data science. While it is possible to practice data analysis without a robust knowledge of algebra, a little bit helps. The purpose here is to highlight and review the key linear algebra concepts and to demonstrate a few examples. By the end of this lab you should be able to:\n\nDescribe the structure of vectors and matrices\nPerform math functions with linear algebra structures\nDemonstrate awareness of linear algebra utility"
  },
  {
    "objectID": "lab01-lin-alg.html#vectors",
    "href": "lab01-lin-alg.html#vectors",
    "title": "Lab 01 Linear alg.",
    "section": "2 Vectors",
    "text": "2 Vectors\n\n2.1 The basic vector concept\nVectors can be conceptualized as a list of numerical values (elements) that may be arranged in columns or rows. A formal difference between column and row vectors is the notation for their arrangement, where a vector has n elements, a row vector is a matrix with \\([1 \\times n]\\) elements; a column vector has \\([n \\times 1]\\) elements.\nColumn vector:\n\\(a=\\begin{bmatrix} 2 \\\\ 1 \\\\ 3 \\end{bmatrix}\\)\nRow vector:\n\\(b=\\begin{bmatrix} 2, 1, 3 \\end{bmatrix}\\)\nVectors have a specific order such that:\n\\((2,1,3) \\neq (1,2,3)\\)\nWe can generalize the notation for a vector containing n elements as an n-vector such that:\n\\(a=\\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{bmatrix}\\)\nwhere each element \\(a_i\\) is a numerical value and the vector can be written as \\(a=(a_1,\\dots,a_n)\\).\nWe can represent vectors graphically, e.g. here is an example in R graphing 2 2-vectors.There are some conventions in geometry and math notation here, that are not necessarily the same as the way we store data structures in a programming language…\n\n# imagine two vectors that each contain the x,y coordinates of a point\nvec1 <- c(2,2)\nvec2 <- c(1,-0.5)\n\n\n\n\n\n\nVectors in R are always printed in the ‘row format’, regardless of math notation.\n\na <- c(4,2,3)\na\n\n[1] 4 2 3\n\n\n\n\n2.2 Transposing\nTansposing a vector is when a column or row vector is turned into the opposite orientation. The transpose is notated with the symbol \\(\\intercal\\)\nColumn to row format\n\\(\\begin{bmatrix} 4 \\\\ 8 \\\\ 5 \\end{bmatrix} ^ \\intercal = [4, 8, 5]\\)\nRow to column format\n\\([4, 8, 5] ^ \\intercal = \\begin{bmatrix} 4 \\\\ 8 \\\\ 5 \\end{bmatrix}\\)\n\n# transpose in R\na <- c(5,7,6)\n\n# the t() function forces the object as a matrix\nt(a)\n\n     [,1] [,2] [,3]\n[1,]    5    7    6\n\n# multiple transpose, just to demonstrate\nt(t(a))\n\n     [,1]\n[1,]    5\n[2,]    7\n[3,]    6\n\n\n\n\n2.3 Multiplication\nA number \\(b\\) and a vector \\(a\\) can be multiplied together\n\\(b \\times a =\\begin{bmatrix} b \\times a_1 \\\\ b \\times a_2 \\\\ \\vdots \\\\ b \\times a_n \\end{bmatrix}\\)\nThus\n\\(5 \\times \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 5 \\\\ 10 \\\\ 15 \\end{bmatrix}\\)\n\n# vector multiplication in R\na <- c(2,4,5)\nb <- 3\n\na*b\n\n[1]  6 12 15\n\n\nGraphing vector multiplication\n\n# our 2 vectors from before\nvec1 <- c(2,2)\nvec2 <- c(1,-0.5)\n\n\n\n\n\n\n\n\n2.4 Addition\nLet \\(a\\) and \\(b\\) be n-vectors, where \\(a\\) and \\(b\\) are of the same dimensions.\n\\(a + b = \\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{bmatrix} + \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n \\end{bmatrix} = \\begin{bmatrix} a_1 + b_1 \\\\ a_2 + b_2 \\\\ \\vdots \\\\ a_n + b_n \\end{bmatrix} = b+a\\)\nWith numbers\n\\(a + b = \\begin{bmatrix} 1 \\\\ 3 \\\\ 5 \\end{bmatrix} + \\begin{bmatrix} 4 \\\\ 2 \\\\ 8 \\end{bmatrix} = \\begin{bmatrix} 5 \\\\ 5 \\\\ 13 \\end{bmatrix}\\)\n\n# vector addition in R\na <- c(3, 5, 1)\nb <- c(14, 3, 5)\n\na + b\n\n[1] 17  8  6\n\n\n\n# our 2 vectors from before\nvec1 <- c(2,2)\nvec2 <- c(1,-0.5)\nvec3 <- vec1 + vec2\n\n\n\n\n\n\n\n\n2.5 Vector inner product\nThe inner product of a vector is obtained by multiplying two vectors and summing the result (NB this is sometimes called the dot product).\n\\(\\sum a*b = a \\cdot b = a_1b_1 + \\dots + a_nb_n\\)\nwith numbers\n\\(\\sum (\\begin{bmatrix} 1 \\\\ 3 \\\\ 5 \\end{bmatrix} \\times \\begin{bmatrix} 4 \\\\ 2 \\\\ 8 \\end{bmatrix}) = \\sum \\begin{bmatrix} 4 \\\\ 6 \\\\ 40 \\end{bmatrix} == 50\\)\n\n# dot product in R\na <- c(1,3,5)\nb <- c(4,2,8)\n\nsum(a * b)\n\n[1] 50\n\n\n\n# alternative syntax for the dot product\na %*% b\n\n     [,1]\n[1,]   50\n\n\n\n\n2.6 Magnitude (aka the “norm”) of a vector\nThere are several ways to measure the “bigness” of a vector, sometimes called the norms. Although we will not go into detail here, there are two types of norm to be aware of. These may seem a little esoteric for our purposes here, but they are used “under the bonnet” for many statistical and machine learning calculations (thus, you may encounter them and should probably be aware of them).\nL1 norm (aka the outer norm) - this is the overall absolute magnitude of vector values\nL2 norm (aka the inner norm) this is the linear (“Euclidean”) distance of the vector from the origin (the zero value in n-dimensional space).\n\nL1 norm\nThe L1 norm is calculated by summing the absolute value of all vector elements.\nTake a vector \\(a = (2, -4, 5)\\)\n\\(||a||_1 = \\sum(|a_1|+ \\dots + |a_n|)\\)\n\\(||a||_1 = (2 + 4 + 5) = 11\\)\n\n\nL2 norm\nThe L2 norm is calculated by taking the square root of the summed values of the squared values of each element of a vector.\nTake a vector \\(b = (-1, 0, 3)\\)\n\\(||b||_2 = \\sqrt(b_1^2+ \\dots + b_n^2)\\)\n\\(||b||_2 = \\sqrt(1 + 0 + 9) = 3.16\\)\n\n# norms in R\na <- c(2, -4, 5)\nb <- c(-1, 0, 3)\n\nsum(abs(a)) # L1\n\n[1] 11\n\nsqrt(sum(b^2)) # L2\n\n[1] 3.162278\n\n# alternative calculation using the norm() function\n# ?norm\n\nnorm(matrix(a), type = \"O\") # L1\n\n[1] 11\n\nnorm(matrix(b), type = \"2\") # L2\n\n[1] 3.162278\n\n\n\n\n\n2.7 Special vectors\nThere are a few special cases of vectors we may encounter (but which are certainly there “doing work” for us), like the 0-vector and the 1-vector. These are simply vectors where all values assume either zero or one, respectively. These are often used in linear models to encode data for matrix calculations (but we will leave it at that for now).\n\n# 0-matrix, n=10\nrep(0, 10)\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n# 1-matrix, n=8\nrep(1, 8)\n\n[1] 1 1 1 1 1 1 1 1\n\n\n\n\n2.8 Orthogonal vectors\nOrthogonal vectors are used in a number of statistical methods, e.g. multivariate statistics like principal component analysis (PCA). Here, orthogonal means perpendicular. We determine orthogonality by taking the inner product of two vectors.\nTake two vectors \\(a\\) and \\(b\\), they are orthogonal if and only if\n\\(a \\perp b \\iff a \\cdot b = 0\\)\n\na <- c(3,-3)\nb <- c(3, 3)\n\nsum(a*b) # yep, a and b are orthogonal!\n\n[1] 0"
  },
  {
    "objectID": "lab01-lin-alg.html#resources",
    "href": "lab01-lin-alg.html#resources",
    "title": "Lab 01 Linear alg.",
    "section": "Resources",
    "text": "Resources\nHere are a few web resources for self learning if you wish to go farther\n3Blue1Brown Essence of linear algebra\nKhan Academy linear algebra series\nCoursera Mathematics for machine learning linear algebra course (Imperial College London - free to audit)\nMIT x18.06 Gilbert Strang’s famous linear algebra course"
  },
  {
    "objectID": "lab01-lin-alg.html#harper-adams-data-science",
    "href": "lab01-lin-alg.html#harper-adams-data-science",
    "title": "Lab 01 Linear alg.",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab01-lin-alg.html#matrices",
    "href": "lab01-lin-alg.html#matrices",
    "title": "Lab 01 Linear alg.",
    "section": "3 Matrices",
    "text": "3 Matrices\n\n3.1 Description\nMatrices are described by the number of rows and columns they have. We may say a matrix \\(A\\) to have dimensions \\(r \\times c\\), (rows \\(\\times\\) columns).\n$ A =\n\\[\\begin{bmatrix} a_{11} & a_{12} & \\dots & a_{1c} \\\\ a_{21} & a_{22} & \\dots & a_{2c} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{r1} & a_{r2} & \\dots & a_{rc} \\end{bmatrix}\\]\n$\n\n# make matrix, vector assembled \"by column\"\nA <- matrix(c(4,3,6,2,7,4,4,5,4), ncol = 3)\nA\n\n     [,1] [,2] [,3]\n[1,]    4    2    4\n[2,]    3    7    5\n[3,]    6    4    4\n\n\nA matrix can be constructed “by row” as well in R, with very different consequences.\n\n# make matrix, vector assembled \"by row\"\nB <- matrix(c(4,3,6,2,7,4,4,5,4), ncol = 3, byrow=T)\nB\n\n     [,1] [,2] [,3]\n[1,]    4    3    6\n[2,]    2    7    4\n[3,]    4    5    4\n\n\n\n\n3.2 Multiplying matrices\nFor a number \\(\\alpha\\) and a matrix \\(A\\), the product of \\(\\alpha A\\) is the matrix obtained by multiplying each element of \\(A\\) to \\(\\alpha\\).\n\\(\\alpha = 3\\)\n$A =\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n$\n$3 \n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix} 3 & 9 \\\\  6 & 12 \\\\ 3 & 3 \\end{bmatrix}\\]\n$\n\n# matrix multiplication in R\nalpha <- 3\nA <- matrix(c(1,3,2,4,1,1), byrow=T, ncol=2)\nalpha*A\n\n     [,1] [,2]\n[1,]    3    9\n[2,]    6   12\n[3,]    3    3\n\n\n\n\n3.3 Transpose for matrices\nMatrix trasposition works similarly to vector transpostiion and is also denoted by \\(\\intercal\\)\n$\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n^ =\n\\[\\begin{bmatrix} 1 & 2 & 1 \\\\  3 & 4 & 1 \\end{bmatrix}\\]\n$\n\n# Matrix transpose in R\nA <- matrix(c(1,3,2,4,1,1), byrow=T, ncol=2)\nt(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    3    4    1\n\n\n\n\n3.4 Sum of matrices\nLet \\(A\\) and \\(B\\) be matrices of dimensions \\(r \\times c\\). We sum the matrices together element-wise. The matrices must be of exactly the same dimensions.\n$\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n\n\\[\\begin{bmatrix} 7 & 1 \\\\  1 & 1 \\\\ 4 & 4 \\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix} 8 & 4 \\\\  3 & 5 \\\\ 5 & 5 \\end{bmatrix}\\]\n$\n\n\n# Adding matrices in R\nA <- matrix(c(1,3,2,4,1,1), byrow=3, ncol=2)\nB <- matrix(c(7,1,1,1,4,4), byrow=3, ncol=2)\n\nA +B\n\n     [,1] [,2]\n[1,]    8    4\n[2,]    3    5\n[3,]    5    5\n\n\n\n\n3.5 Multiplying matrix x vector\nLet \\(A\\) be an \\(r \\times c\\) matrix and ;et \\(B\\) be a column vector with \\(c\\) dimensions Note the number of elements in one dimension (here \\(c\\)) bust be the same.\n$\n\\[\\begin{bmatrix} a_{11} & a_{12} & \\dots & a_{1c} \\\\ a_{21} & a_{22} & \\dots & a_{2c} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{r1} & a_{r2} & \\dots & a_{rc} \\end{bmatrix}\\]\n\\[\\begin{bmatrix} b_{1} \\\\  b_{2} \\\\  \\vdots \\\\ b_{c} \\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix} a_{11} b_{1} + a_{12} b_{2} +  \\dots + a_{1c}b_{c} \\\\ a_{21} b_{1} + a_{22} b_{2} + \\dots + a_{2c} b_{c} \\\\ \\vdots  \\\\ a_{r1} b_{1} + a_{r2} b_{2} +  \\dots   + a_{rc} b_{c} \\end{bmatrix}\\]\n$\n\\(\\begin{bmatrix} 1 & 3 \\\\ 2 & 4 \\\\ 1 & 1 \\end{bmatrix} \\times \\begin{bmatrix} 7 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\cdot 7 + 3 \\cdot 1 \\\\ 2 \\cdot 7 + 4 \\cdot 1 \\\\ 1 \\cdot 7 + 1 \\cdot 1 \\end{bmatrix}\\begin{bmatrix} 10 \\\\ 18 \\\\ 8 \\end{bmatrix}\\)\n\n# Matrix x vector multiplication in R\nA <- matrix(c(1,3,2,4,1,1), byrow=3, ncol=2)\nC <- c(7,1)\n\n# NB the %*% syntax, correct for matrix x vector\nA %*% C\n\n     [,1]\n[1,]   10\n[2,]   18\n[3,]    8\n\n# NB this will also evaluate, but has a different result...\n# Can you tell what is going on here?\nA * C\n\n     [,1] [,2]\n[1,]    7    3\n[2,]    2   28\n[3,]    7    1\n\n\n\n\n3.6 Multiplying matrix x matrix\n(Here it gets tricky)\nLet \\(A\\) be an \\(r \\times c\\) matrix and \\(B\\) be a \\(c \\times t\\) matrix, where the number of columns in \\(A\\) is equal to the number of rows in \\(B\\).\n\n# Matrix x matrix multiplication in R\nA <- matrix(c(1, 3, 2, 2, 8, 9), ncol = 2)\nB <- matrix(c(5, 8, 4, 2), ncol = 2)\n\n# NB the %*% syntax\nA %*% B\n\n     [,1] [,2]\n[1,]   21    8\n[2,]   79   28\n[3,]   82   26\n\n\n\n\n3.7 Vectors as matrics\nVectors can be treated as matrices and in R can be coerced to matrix objects, where a column vector of length \\(r\\) becomes an \\(r \\times 1\\) matrix or a row vector of length \\(c\\) becomes a \\(1 \\times c\\) matrix\n\n# Vectors as matrices in R\n\n# Vanilla numeric vector\n(A <- c(4,5,8)); class(A)\n\n[1] 4 5 8\n\n\n[1] \"numeric\"\n\n# Column matrix\n(A <- matrix(c(4,5,8), nrow=3)); class(A)\n\n     [,1]\n[1,]    4\n[2,]    5\n[3,]    8\n\n\n[1] \"matrix\" \"array\" \n\n# Row matrix\n(A <- matrix(c(4,5,8), ncol=3)); class(A)\n\n     [,1] [,2] [,3]\n[1,]    4    5    8\n\n\n[1] \"matrix\" \"array\" \n\n\n\n\n3.8 Special matrics\n– Square matrix An n × n matrix\n– Symmetric matrix A is if \\(A = A^\\intercal\\).\n– 0-matrix A matrix with 0 on all entries, often written simply as 0.\n– 1-matrix A matrix with 1 on all entries, often written simply as J.\n– Diagonal matrix A square matrix with 0 on all off–diagonal entries and elements d1, d2, … , dn on the diagonal, often written diag{d1, d2, … , dn}\n– Identity matrix is one with with all 1s on the diagonal, denoted I and satisfies that IA = AI = A.\n\n# 0-matrix\nmatrix(0, nrow = 2, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n\n# 1-matrix\nmatrix(1, nrow = 2, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n\n# Diagonal matrix\ndiag(c(1, 2, 3))\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    2    0\n[3,]    0    0    3\n\n# Identity matrix\ndiag(1, 3)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n# Note what happens when diag() is applied to a matrix\n(D <- diag(c(4,3,5)))\n\n     [,1] [,2] [,3]\n[1,]    4    0    0\n[2,]    0    3    0\n[3,]    0    0    5\n\ndiag(D)\n\n[1] 4 3 5\n\n(A <- matrix(c(1,3,2,2,6,8,9,3,4), ncol = 3))\n\n     [,1] [,2] [,3]\n[1,]    1    2    9\n[2,]    3    6    3\n[3,]    2    8    4\n\ndiag(A)\n\n[1] 1 6 4\n\n\n\n\n3.9 Inverse of a matrix\nThe inverse of an \\(n × n\\) matrix \\(A\\) is the \\(n × n\\) matrix \\(B\\) (which is which when multiplied with A gives the identity matrix I. That is, \\(AB = BA = I\\).\nThus\n\\(B\\) is the inverse of \\(A\\), written as \\(B = A^{−1}\\) and\n\\(A\\) is the inverse of \\(B\\), written as \\(A = B^{−1}\\)\nNumeric example\n$ A =\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\end{bmatrix}\\]\nB =\n\\[\\begin{bmatrix} -2 & 1.5 \\\\  1 & -0.5 \\end{bmatrix}\\]\n$\nWe can show \\(AB = BA = I\\), thus \\(B=A^{-1}\\)\n\n# Inverse of matrices\n\n(A <- matrix(c(1,3,2,4), ncol=2, byrow=T))\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n(B <- matrix(c(-2,1.5,1,-0.5), ncol=2, byrow=T))\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\nA%*%B\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\nB%*%A == diag(1,2)\n\n     [,1] [,2]\n[1,] TRUE TRUE\n[2,] TRUE TRUE\n\n\n– Only square matrices can have an inverse, but not all square matrices have an inverse. – When the inverse exists, it is unique. – Finding the inverse of a large matrix A is numerically complicated (but computers do it for us).\n\n# Solving the inverse of a matrix in R using solve()\n\n(A <- matrix(c(1,3,2,4), ncol=2, byrow=T))\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n(B <- solve(A))\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\n# Prove the rule\nA %*% B\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1"
  },
  {
    "objectID": "lab01-lin-alg.html#special-topics",
    "href": "lab01-lin-alg.html#special-topics",
    "title": "Lab 01 Linear alg.",
    "section": "4 Special topics",
    "text": "4 Special topics\n\n4.1 Solving linear equations\nMatrix math is related to math that can be used to solve linear equation systems. This is a very large topic and we will only briefly touch upon it, but it is core in statistics and in machine learning. We can sometimes ignore the details, but awareness of this area of math will likely be beneficial.\nConsider these two linear equations\n\\(x_1 + 3x_2 = 7\\)\n\\(2x_1 + 4x_2 = 10\\)\nWe can write this “system” of equations in matrix form, from which is derived the notation for statistical linear models. Let’s define the matrices \\(A\\), \\(x\\) and \\(b\\) as:\n\\(\\begin{bmatrix} 1 & 3 \\\\ 2 & 4 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 7 \\\\ 10 \\end{bmatrix}\\), i.e. \\(Ax = b\\)\nBecause \\(A^{-1}A = I\\) and \\(Ix=x\\):\n\\(x = A^{-1}b = \\begin{bmatrix} -2 & 1.5 \\\\ 1 & -0.5 \\end{bmatrix} \\begin{bmatrix} 7 \\\\ 10 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\\)\nThis way of thinking is the fountation of the linear model and we can exploit it to isolate and “solve” for the x values. E.g. we can isolate and solve for \\(x_2\\) as:\n\\(x_2 = \\frac{7}{3}-\\frac{1}{3}x_1\\), \\(x_2 = \\frac{10}{4}-\\frac{2}{4}x_1\\)\nNow we can graphically represent these equations, which are two lines and which demonstrate the solutions\n\n\n\n\n\nThe lines represent the solved equations above, and it can be seen that they cross at a single point, the solutions for \\(x_1\\) and \\(x_2\\), \\(x_1 = 1\\) and \\(x_2=2\\), respectively.\n\nA <- matrix(c(1, 2, 3, 4), ncol = 2)\nb <- c(7, 10)\n(x <- solve(A) %*% b)\n\n     [,1]\n[1,]    1\n[2,]    2\n\n\nWhile in this example we see exactly 1 solution, there are several possibilities in general:\n\nExactly one solution – when the lines intersect in one point\nNo solutions – when the lines are parallel but not identical\nInfinitely many solutions – when the lines coincide.\n\n\n\n4.2 Matrix equalities\nHere are a few additional properties of matrices\n\\((A + B)^\\intercal = A^\\intercal + B^\\intercal\\)\n\\((AB)^\\intercal = B^\\intercal A^\\intercal\\)\n\\(A(B + C) = AB + AC\\)\n\\(AB = AC 6) B = C\\)\nIn generel \\(AB \\neq BA\\)\n\\(AI = IA = A\\)\nIf \\(\\alpha\\) is a number then \\(\\alpha AB = A(\\alpha B)\\)\n\n\n4.3 Least squares\nConsider the following paired values\n\ndf <- data.frame(x=c(1,2,3,4,5),\n                 y=c(3.7, 4.2,4.9,5.7,6.0))\ndf\n\n  x   y\n1 1 3.7\n2 2 4.2\n3 3 4.9\n4 4 5.7\n5 5 6.0\n\n\nWe can plot these values and note that the relationship is approvimately linear (i.e., a straight line can be drawn that comes close to all the values)\n\n\n\n\n\nWe can notate the linear relationship between \\(x\\) and \\(y\\) with\n\\(y_i = \\beta_0 +\\beta_1x_i\\) for \\(i = 1, \\dots, 5\\)\nThis can be written in matrix form\n\\(y = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_5 \\end{bmatrix} \\approx \\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\vdots & \\vdots \\\\1 & x_5 \\\\ \\end{bmatrix} \\begin{bmatrix} \\beta_0 \\\\ \\beta_1\\end{bmatrix} = \\mathbf{X \\beta}\\)\nGiven that we have vectors \\(y\\) and \\(x\\), how can we find the vector \\(\\mathbf{\\beta}\\) to satisfy this equality such that \\(y=X \\beta\\)?\nActually, the answer is no because this would require the points to lie on an exactly straight line! However, it may be useful to find an estimate of \\(\\beta\\) such that \\(\\mathbf{X \\beta}\\) is “as close to \\(y\\) as possible”. Let’s call this estimate \\(\\hat{\\beta}\\)\nTo do this we would like to find \\(\\hat{\\beta}\\) that minimizes the equation\n\\(e=y- \\mathbf{X \\beta}\\)\nThe solution to this problem is the basis of linear regression and other linear statistical models:\n\\(\\hat{\\beta} = (X^\\intercal X)^{-1} X^\\intercal y\\)\n\ny <- c(3.7, 4.2,4.9,5.7,6.0)\nx <- c(1,2,3,4,5)\nX <- matrix(c(rep(1,5), x), ncol=2, byrow=F)\ncolnames(X) <- c('','x')\n\ny\n\n[1] 3.7 4.2 4.9 5.7 6.0\n\nX\n\n       x\n[1,] 1 1\n[2,] 1 2\n[3,] 1 3\n[4,] 1 4\n[5,] 1 5\n\n# this solves \"Beta hat\"\n# NB, the intercept and slope coeeficients for linear regression!\n(beta.hat <- solve(t(X) %*% X) %*% t(X) %*% y)\n\n  [,1]\n  3.07\nx 0.61"
  },
  {
    "objectID": "lab01-lin-alg.html#exercises",
    "href": "lab01-lin-alg.html#exercises",
    "title": "Lab 01 Linear alg.",
    "section": "5 Exercises",
    "text": "5 Exercises\n\n5.1 The bird table\nOn a sunny day, two tables are standing in an English country garden. On each table birds of unknown species are sitting having the time of their lives. A bird from the first table says to those on the second table: “Hi – if one of you come to our table then there will be the same number of us on each table”. “Yeah, right”, says a bird from the second table, “but if one of you comes to our table, then we will be twice as many on our table as on yours”.\nQuestion: How many birds are on each table?\n\nWrite up two equations with two unknowns\nSolve these equations using the methods you have learned from linear algebra\nSimply finding the solution by trial–and–error is invalid"
  },
  {
    "objectID": "lec00-module-intro.html#c7081-statistical-analysis-for-data-science",
    "href": "lec00-module-intro.html#c7081-statistical-analysis-for-data-science",
    "title": "c7081 Lec00 Module Introduction",
    "section": "C7081 Statistical Analysis for Data Science",
    "text": "C7081 Statistical Analysis for Data Science\n\nEd Harris"
  },
  {
    "objectID": "lec00-module-intro.html#section",
    "href": "lec00-module-intro.html#section",
    "title": "C7081-2022 Statistical analysis for data science",
    "section": "",
    "text": "C7081 Statistical Analysis for Data Science\nEd Harris"
  },
  {
    "objectID": "lec00-module-intro.html#module-overview",
    "href": "lec00-module-intro.html#module-overview",
    "title": "C7081-2022 Statistical analysis for data science",
    "section": "Module overview",
    "text": "Module overview\n\n\n\n\n“I am always ready to learn although I do not always like being taught.”\n\n-Winston Churchill"
  },
  {
    "objectID": "lec00-module-intro.html#module-overview-1",
    "href": "lec00-module-intro.html#module-overview-1",
    "title": "C7081-2022 Statistical analysis for data science",
    "section": "Module overview",
    "text": "Module overview\n\n\nOne week intensive format\nDaily catch-up meetings\nRecorded lectures, readings\nLabs are critical"
  },
  {
    "objectID": "lab00-welcome.html",
    "href": "lab00-welcome.html",
    "title": "Lab Welcome",
    "section": "",
    "text": "This is a simple activity with a few parts to help get you into the mindset of practicing working with data. We will be doing work to allow you to use some specific skills, but the real point of this exercise is to begin to think about beginning to take responsibility for information you construct using data."
  },
  {
    "objectID": "lab00-welcome.html#harper-adams-data-science",
    "href": "lab00-welcome.html#harper-adams-data-science",
    "title": "Lab Welcome",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab00-welcome.html#bmi-data",
    "href": "lab00-welcome.html#bmi-data",
    "title": "Lab Welcome",
    "section": "1 BMI data",
    "text": "1 BMI data\n\n\n\n\nBMI chart\n\n\n\nThe Body Mass Index (BMI) is a numerical scale intended as a rough guideline to body weight relative to body size. There are a number of assumptions underlying the scale, and the BMI is considered imperfect, but is in wide use.\nThe BMI is calculated thus:\n\\(BMI = \\frac{weight(Kg)}{height(m^2)}\\)\nYou can calculate your own BMI here"
  },
  {
    "objectID": "lab00-welcome.html#data-should-be-tidy",
    "href": "lab00-welcome.html#data-should-be-tidy",
    "title": "Lab Welcome",
    "section": "2 Data should be tidy",
    "text": "2 Data should be tidy\n\n\n\n\nData should be tidy, like your room\n\n\n\nThe concept of tidy data is popular and widely considered best practice. The concept has been summarized in a highly cited paper by Wickham (2014).\nThe essence of the Tidy Data concept is:\n\nSimple data structure, one observation per row\nSimple variable names (informative, short, no spaces, weird characters)\nData explanation or “Data Dictionary” present\nNo extraneous information (like figures, summaries) embedded with the data storage"
  },
  {
    "objectID": "lab00-welcome.html#exercises",
    "href": "lab00-welcome.html#exercises",
    "title": "Lab Welcome",
    "section": "3 Exercises",
    "text": "3 Exercises\n\n3.1 Make tidy data\nUse the following tab-delimited data files: bmi_f.txt bmi_m.txt\nThe data look like this:\n\n\n\nbmi_f.txt\n\n\n\nID, subject ID within each file\nsteps, # steps / wk past 16 weeks\nbmi, bmi measure\nsex is indicated implicitly by males and females data being separated in different files\n\nYour task:\n\nConvert the data to a tidy data format in a single .xlsx file\nDo this using only R code\nData dictionary may be added with code or “manually”\nWe will scrutinize and discuss\n\n\n\n3.2 Analyse BMI data\nConsider three specific hypotheses: \n\nthat there is a statistically significant difference in the average number of steps taken by men and women\nthat there is a negative correlation between the number of steps and the BMI for women\nthat this correlation is positive for men\n\n\nPerform analysis ~30 mins\nDo not speak to others\nWe will discuss of findings as a group\n\n\n\n3.3 Make a data report using markdown\n\nMarkdown is a language\nR markdown is “R flavoured Markdown”\nFormat a “dynamic” report using R Markdown\n\nThe task here is to create a very brief report of your BMI analysis and findings, using R Markdown. The point here is really just to practice markdown and think of how to communicate results to others.\nA markdown document is “freeform” ; the structure I suggest here is a minimal example for good practice.\nTitle + other details - descriptive title, set in the YAML (“YAML ain’t Markup Language”: recursive acronym…) header Summary of major findings - written LAST\nBackground - like the introduction section in a scientific paper. The most important part is a list of OBJECTIVES\nResults Graphs, stats results, terse, clear, technical style\nBibliography (if relevant) References are usually cited in Background, or possibly in Results if there are methods citations\n\nMake your own report (~45 mins)\nStart a new R Markdown document in RStudio, HTML output (NB pdf, word options)\nStructured your doc with the sections: Title, Summary, Background, Results, Bibliography\nThere are usually several “unseen” sections that may contain your R code in code chunks\nWe will discuss and critique resulting reports and code (~45 mins)"
  },
  {
    "objectID": "lab00-welcome.html#resources",
    "href": "lab00-welcome.html#resources",
    "title": "Lab Welcome",
    "section": "Resources",
    "text": "Resources\nR Bootcamp Markdown page"
  },
  {
    "objectID": "lab02-R-practice.html#resources",
    "href": "lab02-R-practice.html#resources",
    "title": "Lab 02 R practice",
    "section": "Resources",
    "text": "Resources\nHere are a few web resources for self learning if you wish to go farther"
  },
  {
    "objectID": "lab02-R-practice.html#harper-adams-data-science",
    "href": "lab02-R-practice.html#harper-adams-data-science",
    "title": "Lab 02 R practice",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab02-R-practice.html",
    "href": "lab02-R-practice.html",
    "title": "Lab 02 R practice",
    "section": "",
    "text": "The purpose of this lab is to practice some R basics that we will begin using right away. If you are already proficient in R and need no practice, feel free to skip ahead to the Exercises to test yourself."
  },
  {
    "objectID": "lab02-R-practice.html#basic-commands",
    "href": "lab02-R-practice.html#basic-commands",
    "title": "Lab 02 R practice",
    "section": "1 Basic commands",
    "text": "1 Basic commands\n\nc()\nR uses functions to perform operations. To run a function called funcname, we type funcname(input1, input2), where the inputs (or arguments) input1 and input2 tell R how to run the function. A function can have any number of inputs. For example, to create a vector of numbers, we use the function c() (for concatenate). Any numbers inside the parentheses are joined together. The following command instructs R to join together the numbers 1, 3, 2, and 5, and to save them as a vector named x. When we type x, it gives us back the vector.\n\nx <- c(1,3,2,5)\nx\n\n[1] 1 3 2 5\n\n\n\n\n<- value assignment\nWe can also “save things” (i.e. assign values) using = rather than <-, though the “arrow” syntax is the standard style in R:\n\nx = c(1,6,2)\nx\n\n[1] 1 6 2\n\ny = c(1,4,3) # why doesn't this \"print out\"?\n\n\n\nlength()\nHitting the up arrow multiple times will display the previous commands, which can then be edited. This is useful since one often wishes to repeat a similar command. In addition, typing ?funcname will always cause R to open a new help file window with additional information about the function funcname. We can tell R to add two sets of numbers together. It will then add the first number from x to the first number from y, and so on. However, x and y should be the same length. We can check their length using the length() function.\n\n\nls() , rm()\nThe ls() function allows us to look at a list of all of the objects, such as data and functions, that we have saved so far. The rm() function can be used to delete any that we don’t want.\n\nls()\n\n[1] \"x\" \"y\"\n\nrm(x,y)\nls()\n\ncharacter(0)\n\n\nIt’s also possible to remove all objects at once without explicitly naming them (handy of you have more than few data objects in you Global Environment):\n\nx = c(1,6,2)\ny = c(1,4,3)\nls()\n\n[1] \"x\" \"y\"\n\nrm(list=ls()) # do you see what the 'list' argument does here?\nls()\n\ncharacter(0)\n\n\n\n\nmatrix()\nThe matrix() function is used to create a matrix of numbers. Before we use the matrix() function, we can learn more about it to examine the arguments:\n\n# ?matrix\n\nThe help ﬁle reveals that the matrix() function takes a number of inputs, but for now we focus on the ﬁrst three: the data (the entries in the matrix), the number of rows, and the number of columns. First, we create a simple matrix.\n\nx <-  matrix( data=c(1 ,2 ,3 ,4) , nrow =2 , ncol =2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nNote that we could just as well omit explicitly typing data=, nrow=, and ncol= in the matrix() command above: that is, we could just type:\n\nx <- matrix ( c(1 ,2 ,3 ,4) ,2 ,2)\n\nand this would have the same effect. However, it can sometimes be useful to specify the names of the arguments passed in, since otherwise R will assume that the function arguments are passed into the function in the same order that is given in the function’s help ﬁle. As this example illustrates, by default R creates matrices by successively ﬁlling in columns. Alternatively, the byrow=TRUE option can be used to populate the matrix in order of the rows.\n\nx <- matrix ( c(1 ,2 ,3 ,4) ,2 ,2, byrow=TRUE)\n\n\n\nsqrt() sqare root\nNotice that in the above command we did not assign the matrix to a value such as x. In this case the matrix is printed to the screen but is not saved for future calculations. The sqrt() function returns the square root of each element of a vector or matrix. The command x^2 raises each element of x to the power 2; any powers are possible, including fractional or negative powers.\n\nsqrt(x)\n\n         [,1]     [,2]\n[1,] 1.000000 1.414214\n[2,] 1.732051 2.000000\n\nx^2\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    9   16\n\n\n\n\nrnorm(), cor() random Gaussian numbers, correlation\nThe rnorm() function generates a vector of random normal variables, with ﬁrst argument n the sample size. Each time we call this function, we will get a diﬀerent answer. Here we create two correlated sets of numbers, x and y, and use the cor() function to compute the correlation between them.\n\nx <- rnorm(50)\ny <- x+ rnorm(50 , mean =50 , sd =.1)\ncor(x, y)\n\n[1] 0.9925639\n\n\n\n\nset.seed makes ‘pseudo-random’ events repeatable\nBy default, rnorm() creates standard normal random variables with a mean of 0 and a standard deviation of 1. However, the mean and standard devi- ation can be altered using the mean and sd arguments, as illustrated above. Sometimes we want our code to reproduce the exact same set of random numbers; we can use the set.seed() function to do this. The set.seed() function takes an (arbitrary) integer argument.\n\nrnorm(5); rnorm(5)\n\n[1] -0.68358538  1.04869277 -0.07825478 -1.37466808 -0.97375113\n\n\n[1]  0.2508831  1.7356847  0.3208933  2.1861302 -0.1152183\n\nset.seed(42); rnorm(5); set.seed(42); rnorm(5)\n\n[1]  1.3709584 -0.5646982  0.3631284  0.6328626  0.4042683\n\n\n[1]  1.3709584 -0.5646982  0.3631284  0.6328626  0.4042683\n\n\nWe will endeavor to use set.seed() throughout the labs whenever we perform calculations involving random quantities. In general this should allow the user to reproduce the results. However, it should be noted that as new versions of R become available discrepancies may form between the labs and the output from R.\n\n\nmean(), sd(), and var()\nThe mean() and var() functions can be used to compute the mean and variance of a vector of numbers. Applying sqrt() to the output of var() will give the standard deviation. Or we can simply use the sd() function.\n\nset.seed(3)\ny <- rnorm(100, 10, 1)\nmean(y)\n\n[1] 10.01104\n\nvar(y)\n\n[1] 0.7328675\n\nsqrt(y)\n\n  [1] 3.006338 3.115682 3.202934 2.974537 3.193084 3.167037 3.175755 3.334158\n  [9] 2.963299 3.356690 3.042239 2.978050 3.046907 3.201976 3.186228 3.113253\n [17] 3.007820 3.058064 3.350271 3.193714 3.069449 3.009601 3.129900 2.886785\n [25] 3.084728 3.042849 3.340751 3.318443 3.150860 2.977116 3.301609 3.294203\n [33] 3.275319 3.276660 3.106102 3.271928 3.361601 3.168320 3.003451 3.285386\n [41] 3.284282 3.112802 3.420363 3.034041 3.216899 2.781115 3.136526 3.336295\n [49] 3.089410 3.016759 3.275185 3.031593 3.204229 2.874498 2.930627 3.089733\n [57] 2.994079 3.370778 3.304157 3.035598 3.251695 3.304269 3.202544 3.217447\n [65] 3.342804 3.085313 3.095347 3.309851 2.951439 3.191582 3.157321 3.235289\n [73] 3.320271 3.204272 3.198723 3.278352 3.349189 3.222322 3.001991 3.137379\n [81] 3.425717 3.106075 3.269349 3.350284 3.285467 3.161265 3.196741 3.018863\n [89] 3.231062 3.018876 3.024265 3.001667 3.057633 3.324748 3.099858 3.151097\n [97] 3.088357 3.246676 3.306302 3.129014\n\nsd(y)\n\n[1] 0.8560768"
  },
  {
    "objectID": "lab02-R-practice.html#basic-graphics",
    "href": "lab02-R-practice.html#basic-graphics",
    "title": "Lab 02 R practice",
    "section": "2 Basic graphics",
    "text": "2 Basic graphics\n\nplot()\nThe plot() function is the primary way to plot data in R. For instance, plot(x,y) produces a scatterplot of the numbers in x versus the numbers in y. There are many additional options that can be passed in to the plot() function. For example, passing in the argument xlab will result in a label on the x-axis. To ﬁnd out more information about the plot() function, don’t forget to use ?plot.\n\nx <- rnorm(100)\ny <- rnorm(100)\nplot(x,y) # yuck\n\n\n\nplot(x,y, xlab=\" this is the x- axis\", \n     ylab =\" this is the y - axis\", \n     main =\" Plot of X vs Y \") # better\n\n\n\n\n\n\nOutput functions pdf(), png(), jpg()\nWe will often want to save the output of an R plot. The command that we use to do this will depend on the ﬁle type that we would like to create. For instance, to create a pdf, we use the pdf() function, and to create a jpeg, we use the jpeg() function, png(), etc.\n\n# This code will output a graph file to your working directory\npng(\"MyFigure.png\") # think of this as opening the file\nplot(x, y, pch=16, col =\"green\") # writing something for that file\ndev.off() # turning off the output to file\n\npng \n  2 \n\n\nThe function dev.off() indicates to R that we are done creating the plot. Alternatively, we can simply copy the plot window and paste it into an appropriate ﬁle type, such as a Word document.\n\n\nseq()\nThe function seq() can be used to create a sequence of numbers. For instance, seq(a,b) makes a vector of integers between a and b. There are many other options: for instance, seq(0,1,length=10) makes a sequence of 10 numbers that are equally spaced between 0 and 1. Typing 3:11 is a shorthand for seq(3,11) for integer arguments.\n\nx <- seq(1,10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx <- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx <- seq(-pi, pi, length = 50)\nx\n\n [1] -3.14159265 -3.01336438 -2.88513611 -2.75690784 -2.62867957 -2.50045130\n [7] -2.37222302 -2.24399475 -2.11576648 -1.98753821 -1.85930994 -1.73108167\n[13] -1.60285339 -1.47462512 -1.34639685 -1.21816858 -1.08994031 -0.96171204\n[19] -0.83348377 -0.70525549 -0.57702722 -0.44879895 -0.32057068 -0.19234241\n[25] -0.06411414  0.06411414  0.19234241  0.32057068  0.44879895  0.57702722\n[31]  0.70525549  0.83348377  0.96171204  1.08994031  1.21816858  1.34639685\n[37]  1.47462512  1.60285339  1.73108167  1.85930994  1.98753821  2.11576648\n[43]  2.24399475  2.37222302  2.50045130  2.62867957  2.75690784  2.88513611\n[49]  3.01336438  3.14159265"
  },
  {
    "objectID": "lab02-R-practice.html#special-plots",
    "href": "lab02-R-practice.html#special-plots",
    "title": "Lab 02 R practice",
    "section": "3 Special plots",
    "text": "3 Special plots\n\ncontour() plot\nWe will now create some more sophisticated plots. The contour() function produces a contour plot in order to represent three-dimensional data; it is like a topographical map. It takes three arguments:\n\nA vector of the x values (the ﬁrst dimension),\nA vector of the y values (the second dimension), and\nA matrix whose elements correspond to the z value (the third dimension) for each pair of (x,y) coordinates.\n\nAs with the plot() function, there are many other inputs that can be used to ﬁne tune the output of the contour() function. To learn more about these, take a look at the help ﬁle by typing ?contour.\n\n# don't worry too much about this code, but can you figure out what it does?\n\nx <- y <- 1:10\nf <- outer(x,y, function(x,y) cos(y)/(1+x^2))\ncontour(x,y,f)\n\n\n\nfa <- ( f- t(f))/2\ncontour (x,y, fa , nlevels = 15)\n\n\n\n\n\n\nimage() and persp()\nThe image() function works the same way as contour(), except that it produces a color-coded plot whose colors depend on the z value. This is known as a heatmap, and is sometimes used to plot temperature in weather forecasts. Alternatively, persp() can be used to produce a three-dimensional plot. The arguments theta and phi control the angles at which the plot is viewed.\n\nimage(x, y, fa)\n\n\n\npersp(x, y, fa)\n\n\n\npersp(x, y, fa, theta =30)\n\n\n\npersp(x, y, fa, theta =30, phi = 20) # not enough\n\n\n\npersp(x, y, fa, theta =30, phi = 70) # too much\n\n\n\npersp(x, y, fa, theta =30, phi = 40) # juust right"
  },
  {
    "objectID": "lab02-R-practice.html#indexing-data",
    "href": "lab02-R-practice.html#indexing-data",
    "title": "Lab 02 R practice",
    "section": "4 Indexing data",
    "text": "4 Indexing data\n\nIndexing values\nWe often wish to examine part of a set of data. Suppose that our data is stored in the matrix A.\n\nA <- matrix(1:16, 4, 4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\nThen submitting:\n\nA[2,3]\n\n[1] 10\n\n\nwill select the element corresponding to the second row and the third co umn. The ﬁrst number after the open-bracket symbol [ always refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by providing vectors as the indices.\n\nA[c(1,3), c(2,4)]\n\n     [,1] [,2]\n[1,]    5   13\n[2,]    7   15\n\nA[1:3, 2:4]\n\n     [,1] [,2] [,3]\n[1,]    5    9   13\n[2,]    6   10   14\n[3,]    7   11   15\n\nA[1:2,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n\nA[,1:2]\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n\nThe last two examples include either no index for the columns or no index for the rows. These indicate that R should include all columns or all rows, respectively. R treats a single row or column of a matrix as a vector.\n\nA[1,]\n\n[1]  1  5  9 13\n\n\nThe use of a negative sign - in the index tells R to keep all rows or columns except those indicated in the index.\n\nA[-c(1,3),]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n\nA[-c(1 ,3) ,-c(1 ,3 ,4)]\n\n[1] 6 8\n\n\n\n\ndim()\nThe dim() function outputs the number of rows followed by the number of columns of a given matrix.\n\ndim(A)\n\n[1] 4 4"
  },
  {
    "objectID": "lab02-R-practice.html#data-operations",
    "href": "lab02-R-practice.html#data-operations",
    "title": "Lab 02 R practice",
    "section": "4 Data operations",
    "text": "4 Data operations\n\nIndexing values\nWe often wish to examine part of a set of data. Suppose that our data is stored in the matrix A.\n\nA <- matrix(1:16, 4, 4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\nThen submitting:\n\nA[2,3]\n\n[1] 10\n\n\nwill select the element corresponding to the second row and the third co umn. The ﬁrst number after the open-bracket symbol [ always refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by providing vectors as the indices.\n\nA[c(1,3), c(2,4)]\n\n     [,1] [,2]\n[1,]    5   13\n[2,]    7   15\n\nA[1:3, 2:4]\n\n     [,1] [,2] [,3]\n[1,]    5    9   13\n[2,]    6   10   14\n[3,]    7   11   15\n\nA[1:2,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n\nA[,1:2]\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n\nThe last two examples include either no index for the columns or no index for the rows. These indicate that R should include all columns or all rows, respectively. R treats a single row or column of a matrix as a vector.\n\nA[1,]\n\n[1]  1  5  9 13\n\n\nThe use of a negative sign - in the index tells R to keep all rows or columns except those indicated in the index.\n\nA[-c(1,3),]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n\nA[-c(1 ,3) ,-c(1 ,3 ,4)]\n\n[1] 6 8\n\n\n\n\ndim()\nThe dim() function outputs the number of rows followed by the number of columns of a given matrix.\n\ndim(A)\n\n[1] 4 4\n\n\n\n\nLoading data\nFor most analyses, the ﬁrst step involves importing a data set into R. The read.table() function is one of the primary ways to do this. The help ﬁle contains details about how to use this function. We can use the function write.table() to export data.\nBefore attempting to load a data set, we must make sure that R knows to search for the data in the proper directory. For example on a Windows system one could select the directory using the Change dir... option under the File menu. However, the details of how to do this depend on the operating system (e.g. Windows, Mac, Unix) that is being used.\nHere you will begin by loading in the Auto data set, which is part of the R library {ISLR2}, but to illustrate the read.table() function we load it now from a text ﬁle. The following command will load the Auto.data ﬁle into R and store it as an object called Auto, in a format referred to as a data frame.\n\n\nAuto data\nDownload the Auto.csv data file\nOnce the data has been loaded, the fix() function can be used to view it in a spreadsheet like window. However, the window must be closed before further R commands can be entered.\n\n# Your code may look similar\n# Auto <- read.csv(\"Auto.csv\")\n# fix(Auto)\n\nPeek at the data (note the view may wrap around the lines)\n\nNote that data like these are usually simply a text ﬁle, which you could alternatively open on your computer using a standard text editor. It is often a good idea to view a data set using a text editor or other software such as Excel before loading it into R…\nThis particular data set has probably not loaded correctly for you on the first try, because\n\nR has assumed that the variable names are part of the data and so has included them in the ﬁrst row.\nThe data set also includes a number of missing observations, indicated by a question mark ?.\nThere is a problematic character (at least one…) in the name variable on row 12.\n\nMissing values are a common occurrence in real data sets. Using the argument header=T (or header=TRUE) in the read.table() function tells R that the ﬁrst line of the ﬁle contains the variable names, and using the option na.strings tells R that any time it sees a particular character or set of characters (such as a question mark), it should be treated as a missing element of the data matrix.\n\n# try this\n# Auto <- read.csv(\"data/Auto.csv\", sep = ',', header = T , na.strings = \"?\")\n# fix(Auto)\n\nOnce the data are loaded correctly\n\n# try this\n\n# dim(Auto)\n# Auto[1:4, ]\n# names(Auto)\n\n\n\nGraphical and numerical summary\nWe can use the plot() function to produce scatterplots of the quantitative variables. However, simply typing the variable names will produce an error message, because R does not know to look inside the Auto data object for those variables.\n\n\n\n\n# try this\n# plot(cylinders, mpg) #error\n# Error in plot(cylinders, mpg) : object 'cylinders' not found\n\n\nplot( Auto$cylinders,  Auto$mpg )\n\n\n\n\n\n\nattach()\nTo refer to a variable explicitly, we can type the data set and the variable name joined with a $ (cash) symbol. Alternatively, we can use the attach() function in order to tell R to make the variables in this data frame available by name.\n\nattach(Auto)\nplot(cylinders, mpg)\n\n\n\n\nThe cylinders variable is stored as a numeric vector, so R has treated it as quantitative. However, since there are only a small number of possible values for cylinders, one may prefer to treat it as a qualitative variable. The as.factor() function converts quantitative variables into qualitative variables.\n\ncylinders <- as.factor(cylinders)\n\nIf a variable plotted on the x-axis is categorial, then boxplots will automatically be produced by the plot() function. As usual, a number of options can be speciﬁed in order to customize the plots.\n\nplot(cylinders, mpg)\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\") # Ed's favourite R colour\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\", varwidth = T)\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\", varwidth = T , horizontal = T)\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\", varwidth = T , \n     xlab=\"cylinders\", ylab =\"MPG\")\n\n\n\n\n\n\nhist()\nThe hist() function can be used to plot a histogram. Note that indexing the base color pallette numerically is possible, such that col=2 has the same effect as col=\"red\".\n\nhist(mpg)\n\n\n\nhist(mpg, col = 2)\n\n\n\nhist(mpg, col = 2, breaks = 15)\n\n\n\n\n\n\npairs()\nThe pairs() function creates a scatterplot matrix i.e. a scatterplot for every pair of variables for any given data set. We can also produce scatterplots for just a subset of the variables.\n\npairs(~ mpg + displacement + horsepower + weight + acceleration, Auto )\n\n\n\n\n\n\nidentify()\nIn conjunction with the plot() function, identify() provides a useful interactive method for identifying the value for a particular variable for points on a plot. We pass in three arguments to identify(): the x-axis variable, the y-axis variable, and the variable whose values we would like to see printed for each point. Then clicking on a given point in the plot will cause R to print the value of the variable of interest. Right-clicking on the plot will exit the identify() function (control-click on a Mac). The numbers printed under the identify() function correspond to the rows for the selected points.\n\nplot(horsepower, mpg)\n\n\n\n# this only works on your local machine - try it\n# identify(horsepower, mpg, name)\n\n\n\nsummary()\nThe summary() function produces a numerical summary of each variable in a particular data set.\n\nsummary(Auto)\n\n      mpg          cylinders      displacement     horsepower        weight    \n Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 46.0   Min.   :1613  \n 1st Qu.:17.00   1st Qu.:4.000   1st Qu.:105.0   1st Qu.: 75.0   1st Qu.:2225  \n Median :22.75   Median :4.000   Median :151.0   Median : 93.5   Median :2804  \n Mean   :23.45   Mean   :5.472   Mean   :194.4   Mean   :104.5   Mean   :2978  \n 3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:275.8   3rd Qu.:126.0   3rd Qu.:3615  \n Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :230.0   Max.   :5140  \n                                                                               \n  acceleration        year           origin                      name    \n Min.   : 8.00   Min.   :70.00   Min.   :1.000   amc matador       :  5  \n 1st Qu.:13.78   1st Qu.:73.00   1st Qu.:1.000   ford pinto        :  5  \n Median :15.50   Median :76.00   Median :1.000   toyota corolla    :  5  \n Mean   :15.54   Mean   :75.98   Mean   :1.577   amc gremlin       :  4  \n 3rd Qu.:17.02   3rd Qu.:79.00   3rd Qu.:2.000   amc hornet        :  4  \n Max.   :24.80   Max.   :82.00   Max.   :3.000   chevrolet chevette:  4  \n                                                 (Other)           :365  \n\n\nFor qualitative variables such as name, R will list the number of observations that fall in each category. We can also produce a summary of just a single variable.\n\nsummary(mpg)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.00   17.00   22.75   23.45   29.00   46.60 \n\n\n\n\nEnding your R session\nOnce we have ﬁnished using R, we type q() in order to shut it down, or quit. When exiting R, we have the option to save the current workspace so that all objects (such as data sets) that we have created in this R session will be available next time. Before exiting R, we may want to save a record of all of the commands that we typed in the most recent session; this can be accomplished using the savehistory() function. Next time we enter R, we can load that history using the loadhistory() function (useful in some circumstances)."
  }
]