[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Welcome to C7081. This module is a survey of machine learning and statistical methods including supervised and unsupervised classification, regression, and tree-based methods. There is an emphasis on practical applications using a series of data stories and lab exercises, along with lectures on selected topics and readings. A prerequisite is a basic working knowledge of R programming and introductory statistics."
  },
  {
    "objectID": "index.html#c7081-resources",
    "href": "index.html#c7081-resources",
    "title": "Home",
    "section": "C7081 Resources",
    "text": "C7081 Resources\n\nTextbook: James et al. 2021 Introduction to statistical learning 2ed\nSlack workspace (for enrolled students)\nOffice hours (Slack, Fridays by appointment)"
  },
  {
    "objectID": "index.html#harper-adams-data-science",
    "href": "index.html#harper-adams-data-science",
    "title": "Home",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab01.html#c7081-resources",
    "href": "lab01.html#c7081-resources",
    "title": "Lab 01 linear alg.",
    "section": "C7081 Resources",
    "text": "C7081 Resources"
  },
  {
    "objectID": "lab01.html#harper-adams-data-science",
    "href": "lab01.html#harper-adams-data-science",
    "title": "Lab 01 linear alg.",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "The material in this module is designed to be experienced in an intensive one week format followed by an assessment meant to showcase data science skills (e.g. a github project website that could be part of your cv). For enrolled students, the work will be supported with several live sessions during the main week of delivery.\n\n\n\n\nDay\nTopics\nLabs\nReadings\n\n\n\n\nInduction\n welcome activity \nLab welcome exercise\n\n\n\nMon\n*lecture videos password: data4life\n 00 Module overview\n 01 Introduction 1.1 1.2\n 02 Statistical learning 2.1 2.2\nLab guidance\nLab 01 Linear algebra fun\nLab 02 R programming refresh\nJames et al. 2021 Ch 1,2\nEfron 2020\n\n\nTues\n 03 Linear regression 3.1 3.2\n 04 Classification 4.1 4.2\nLab 03 Linear regression\nLab 04 Classification\nJames et al. 2021 Ch 3,4\nMelesse 2018\n\n\nWed\n 05 Bootstrapping 5.1 5.2\n 06 Model selection 6.1 6.2 6.3\nLab 05 Resampling\nLab 06 Model selection\nJames et al. 2021 Ch 5,6\nAho 2014\n\n\nThurs\n 07 Non-linear models 7.1 7.2\n 08 Decision trees 8.1 8.2 8.3 8.4\nLab 07 Non-linear models\nLab 08 Decision trees\nJames et al. 2021 Ch 7,8\nBarnard 2019\nOtukei 2010\n\n\nFri\n 09 Support vector machines 9.1 9.2\n 10 Unsupervised learning 10.1 10.2 10.3\nLab 09 SVM\nLab 10 Unsupervised learning\nJames et al. 2021 Ch 9,12\nEbrahimi 2017\nHowell 2020"
  },
  {
    "objectID": "schedule.html#references",
    "href": "schedule.html#references",
    "title": "Schedule",
    "section": "References",
    "text": "References\nTextbook: James et al. 2021 Introduction to statistical learning 2ed\nall refs zip\nAho, K., Derryberry, D., Peterson, T., 2014. Model selection for ecologists: the worldviews of AIC and BIC. Ecology 95, 631–636.\nBarnard, D.M., Germino, M.J., Pilliod, D.S., Arkle, R.S., Applestein, C., Davidson, B.E., Fisk, M.R., 2019. Cannot see the random forest for the decision trees: selecting predictive models for restoration ecology. Restoration Ecology 27, 1053–1063.\nEbrahimi, M.A., Khoshtaghaza, M.H., Minaei, S., Jamshidi, B., 2017. Vision-based pest detection based on SVM classification method. Computers and Electronics in Agriculture 137, 52–58.\nEfron, B., 2020. Prediction, Estimation, and Attribution. Journal of the American Statistical Association 115, 636–655.\nHowell, O., Wenping, C., Marsland, R., Mehta, P., 2020. Machine learning as ecology. J. Phys. A: Math. Theor. 53, 334001.\nJames, G., Witten, D., Hastie, T., Tibshirani, R., 2021. An Introduction to Statistical Learning: with Applications in R, Springer Texts in Statistics 2ed. Springer-Verlag, New York.\nMelesse, S., Sobratee, N., Workneh, T., 2016. Application of logistic regression statistical technique to evaluate tomato quality subjected to different pre- and post-harvest treatments. Biological Agriculture & Horticulture 32, 277–287.\nOtukei, J.R., Blaschke, T., 2010. Land cover change assessment using decision trees, support vector machines and maximum likelihood classification algorithms. International Journal of Applied Earth Observation and Geoinformation, Supplement Issue on “Remote Sensing for Africa – A Special Collection from the African Association for Remote Sensing of the Environment (AARSE)” 12, S27–S31."
  },
  {
    "objectID": "schedule.html#harper-adams-data-science",
    "href": "schedule.html#harper-adams-data-science",
    "title": "Schedule",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab00-guidance.html",
    "href": "lab00-guidance.html",
    "title": "Lab Guidance",
    "section": "",
    "text": "There are several recommendations you should follow to get the most out of these exercises and this module as a whole.\n\nSet up a separate script for each lab (e.g. an R script) to organize and document your work\nAnswer each question formally and fully\nUse a fully commented, reproducible script style with a Header, Contents, and clickable Section blocks. This will help you practice Best Practice (see what I did there?), and will make the script useful to yourself in the future as a reference (e.g., the next time you want to set up a K means analysis script…)\nType 100% of your own code: do not copy and paste anything (practice, practice + troubleshooting error messages for typos and other issues)\nConsider writing your lab scripts using R Markdown\nConsider setting up a Github repository for your lab scripts"
  },
  {
    "objectID": "lab00-guidance.html#harper-adams-data-science",
    "href": "lab00-guidance.html#harper-adams-data-science",
    "title": "Lab Guidance",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab01-lin-alg.html",
    "href": "lab01-lin-alg.html",
    "title": "Lab 01 Linear alg.",
    "section": "",
    "text": "Linear algebra is the (math) foundation of statistics and data science. While it is possible to practice data analysis without a robust knowledge of algebra, a little bit helps. The purpose here is to highlight and review the key linear algebra concepts and to demonstrate a few examples. By the end of this lab you should be able to:\n\nDescribe the structure of vectors and matrices\nPerform math functions with linear algebra structures\nDemonstrate awareness of linear algebra utility"
  },
  {
    "objectID": "lab01-lin-alg.html#vectors",
    "href": "lab01-lin-alg.html#vectors",
    "title": "Lab 01 Linear alg.",
    "section": "2 Vectors",
    "text": "2 Vectors\n\n2.1 The basic vector concept\nVectors can be conceptualized as a list of numerical values (elements) that may be arranged in columns or rows. A formal difference between column and row vectors is the notation for their arrangement, where a vector has n elements, a row vector is a matrix with \\([1 \\times n]\\) elements; a column vector has \\([n \\times 1]\\) elements.\nColumn vector:\n\\(a=\\begin{bmatrix} 2 \\\\ 1 \\\\ 3 \\end{bmatrix}\\)\nRow vector:\n\\(b=\\begin{bmatrix} 2, 1, 3 \\end{bmatrix}\\)\nVectors have a specific order such that:\n\\((2,1,3) \\neq (1,2,3)\\)\nWe can generalize the notation for a vector containing n elements as an n-vector such that:\n\\(a=\\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{bmatrix}\\)\nwhere each element \\(a_i\\) is a numerical value and the vector can be written as \\(a=(a_1,\\dots,a_n)\\).\nWe can represent vectors graphically, e.g. here is an example in R graphing 2 2-vectors.There are some conventions in geometry and math notation here, that are not necessarily the same as the way we store data structures in a programming language…\n\n# imagine two vectors that each contain the x,y coordinates of a point\nvec1 <- c(2,2)\nvec2 <- c(1,-0.5)\n\n\n\n\n\n\nVectors in R are always printed in the ‘row format’, regardless of math notation.\n\na <- c(4,2,3)\na\n\n[1] 4 2 3\n\n\n\n\n2.2 Transposing\nTansposing a vector is when a column or row vector is turned into the opposite orientation. The transpose is notated with the symbol \\(\\intercal\\)\nColumn to row format\n\\(\\begin{bmatrix} 4 \\\\ 8 \\\\ 5 \\end{bmatrix} ^ \\intercal = [4, 8, 5]\\)\nRow to column format\n\\([4, 8, 5] ^ \\intercal = \\begin{bmatrix} 4 \\\\ 8 \\\\ 5 \\end{bmatrix}\\)\n\n# transpose in R\na <- c(5,7,6)\n\n# the t() function forces the object as a matrix\nt(a)\n\n     [,1] [,2] [,3]\n[1,]    5    7    6\n\n# multiple transpose, just to demonstrate\nt(t(a))\n\n     [,1]\n[1,]    5\n[2,]    7\n[3,]    6\n\n\n\n\n2.3 Multiplication\nA number \\(b\\) and a vector \\(a\\) can be multiplied together\n\\(b \\times a =\\begin{bmatrix} b \\times a_1 \\\\ b \\times a_2 \\\\ \\vdots \\\\ b \\times a_n \\end{bmatrix}\\)\nThus\n\\(5 \\times \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 5 \\\\ 10 \\\\ 15 \\end{bmatrix}\\)\n\n# vector multiplication in R\na <- c(2,4,5)\nb <- 3\n\na*b\n\n[1]  6 12 15\n\n\nGraphing vector multiplication\n\n# our 2 vectors from before\nvec1 <- c(2,2)\nvec2 <- c(1,-0.5)\n\n\n\n\n\n\n\n\n2.4 Addition\nLet \\(a\\) and \\(b\\) be n-vectors, where \\(a\\) and \\(b\\) are of the same dimensions.\n\\(a + b = \\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{bmatrix} + \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n \\end{bmatrix} = \\begin{bmatrix} a_1 + b_1 \\\\ a_2 + b_2 \\\\ \\vdots \\\\ a_n + b_n \\end{bmatrix} = b+a\\)\nWith numbers\n\\(a + b = \\begin{bmatrix} 1 \\\\ 3 \\\\ 5 \\end{bmatrix} + \\begin{bmatrix} 4 \\\\ 2 \\\\ 8 \\end{bmatrix} = \\begin{bmatrix} 5 \\\\ 5 \\\\ 13 \\end{bmatrix}\\)\n\n# vector addition in R\na <- c(3, 5, 1)\nb <- c(14, 3, 5)\n\na + b\n\n[1] 17  8  6\n\n\n\n# our 2 vectors from before\nvec1 <- c(2,2)\nvec2 <- c(1,-0.5)\nvec3 <- vec1 + vec2\n\n\n\n\n\n\n\n\n2.5 Vector inner product\nThe inner product of a vector is obtained by multiplying two vectors and summing the result (NB this is sometimes called the dot product).\n\\(\\sum a*b = a \\cdot b = a_1b_1 + \\dots + a_nb_n\\)\nwith numbers\n\\(\\sum (\\begin{bmatrix} 1 \\\\ 3 \\\\ 5 \\end{bmatrix} \\times \\begin{bmatrix} 4 \\\\ 2 \\\\ 8 \\end{bmatrix}) = \\sum \\begin{bmatrix} 4 \\\\ 6 \\\\ 40 \\end{bmatrix} == 50\\)\n\n# dot product in R\na <- c(1,3,5)\nb <- c(4,2,8)\n\nsum(a * b)\n\n[1] 50\n\n\n\n# alternative syntax for the dot product\na %*% b\n\n     [,1]\n[1,]   50\n\n\n\n\n2.6 Magnitude (aka the “norm”) of a vector\nThere are several ways to measure the “bigness” of a vector, sometimes called the norms. Although we will not go into detail here, there are two types of norm to be aware of. These may seem a little esoteric for our purposes here, but they are used “under the bonnet” for many statistical and machine learning calculations (thus, you may encounter them and should probably be aware of them).\nL1 norm (aka the outer norm) - this is the overall absolute magnitude of vector values\nL2 norm (aka the inner norm) this is the linear (“Euclidean”) distance of the vector from the origin (the zero value in n-dimensional space).\n\nL1 norm\nThe L1 norm is calculated by summing the absolute value of all vector elements.\nTake a vector \\(a = (2, -4, 5)\\)\n\\(||a||_1 = \\sum(|a_1|+ \\dots + |a_n|)\\)\n\\(||a||_1 = (2 + 4 + 5) = 11\\)\n\n\nL2 norm\nThe L2 norm is calculated by taking the square root of the summed values of the squared values of each element of a vector.\nTake a vector \\(b = (-1, 0, 3)\\)\n\\(||b||_2 = \\sqrt(b_1^2+ \\dots + b_n^2)\\)\n\\(||b||_2 = \\sqrt(1 + 0 + 9) = 3.16\\)\n\n# norms in R\na <- c(2, -4, 5)\nb <- c(-1, 0, 3)\n\nsum(abs(a)) # L1\n\n[1] 11\n\nsqrt(sum(b^2)) # L2\n\n[1] 3.162278\n\n# alternative calculation using the norm() function\n# ?norm\n\nnorm(matrix(a), type = \"O\") # L1\n\n[1] 11\n\nnorm(matrix(b), type = \"2\") # L2\n\n[1] 3.162278\n\n\n\n\n\n2.7 Special vectors\nThere are a few special cases of vectors we may encounter (but which are certainly there “doing work” for us), like the 0-vector and the 1-vector. These are simply vectors where all values assume either zero or one, respectively. These are often used in linear models to encode data for matrix calculations (but we will leave it at that for now).\n\n# 0-matrix, n=10\nrep(0, 10)\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n# 1-matrix, n=8\nrep(1, 8)\n\n[1] 1 1 1 1 1 1 1 1\n\n\n\n\n2.8 Orthogonal vectors\nOrthogonal vectors are used in a number of statistical methods, e.g. multivariate statistics like principal component analysis (PCA). Here, orthogonal means perpendicular. We determine orthogonality by taking the inner product of two vectors.\nTake two vectors \\(a\\) and \\(b\\), they are orthogonal if and only if\n\\(a \\perp b \\iff a \\cdot b = 0\\)\n\na <- c(3,-3)\nb <- c(3, 3)\n\nsum(a*b) # yep, a and b are orthogonal!\n\n[1] 0"
  },
  {
    "objectID": "lab01-lin-alg.html#resources",
    "href": "lab01-lin-alg.html#resources",
    "title": "Lab 01 Linear alg.",
    "section": "Resources",
    "text": "Resources\nHere are a few web resources for self learning if you wish to go farther\n3Blue1Brown Essence of linear algebra\nKhan Academy linear algebra series\nCoursera Mathematics for machine learning linear algebra course (Imperial College London - free to audit)\nMIT x18.06 Gilbert Strang’s famous linear algebra course"
  },
  {
    "objectID": "lab01-lin-alg.html#harper-adams-data-science",
    "href": "lab01-lin-alg.html#harper-adams-data-science",
    "title": "Lab 01 Linear alg.",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab01-lin-alg.html#matrices",
    "href": "lab01-lin-alg.html#matrices",
    "title": "Lab 01 Linear alg.",
    "section": "3 Matrices",
    "text": "3 Matrices\n\n3.1 Description\nMatrices are described by the number of rows and columns they have. We may say a matrix \\(A\\) to have dimensions \\(r \\times c\\), (rows \\(\\times\\) columns).\n$ A =\n\\[\\begin{bmatrix} a_{11} & a_{12} & \\dots & a_{1c} \\\\ a_{21} & a_{22} & \\dots & a_{2c} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{r1} & a_{r2} & \\dots & a_{rc} \\end{bmatrix}\\]\n$\n\n# make matrix, vector assembled \"by column\"\nA <- matrix(c(4,3,6,2,7,4,4,5,4), ncol = 3)\nA\n\n     [,1] [,2] [,3]\n[1,]    4    2    4\n[2,]    3    7    5\n[3,]    6    4    4\n\n\nA matrix can be constructed “by row” as well in R, with very different consequences.\n\n# make matrix, vector assembled \"by row\"\nB <- matrix(c(4,3,6,2,7,4,4,5,4), ncol = 3, byrow=T)\nB\n\n     [,1] [,2] [,3]\n[1,]    4    3    6\n[2,]    2    7    4\n[3,]    4    5    4\n\n\n\n\n3.2 Multiplying matrices\nFor a number \\(\\alpha\\) and a matrix \\(A\\), the product of \\(\\alpha A\\) is the matrix obtained by multiplying each element of \\(A\\) to \\(\\alpha\\).\n\\(\\alpha = 3\\)\n$A =\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n$\n$3 \n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix} 3 & 9 \\\\  6 & 12 \\\\ 3 & 3 \\end{bmatrix}\\]\n$\n\n# matrix multiplication in R\nalpha <- 3\nA <- matrix(c(1,3,2,4,1,1), byrow=T, ncol=2)\nalpha*A\n\n     [,1] [,2]\n[1,]    3    9\n[2,]    6   12\n[3,]    3    3\n\n\n\n\n3.3 Transpose for matrices\nMatrix trasposition works similarly to vector transpostiion and is also denoted by \\(\\intercal\\)\n$\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n^ =\n\\[\\begin{bmatrix} 1 & 2 & 1 \\\\  3 & 4 & 1 \\end{bmatrix}\\]\n$\n\n# Matrix transpose in R\nA <- matrix(c(1,3,2,4,1,1), byrow=T, ncol=2)\nt(A)\n\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    3    4    1\n\n\n\n\n3.4 Sum of matrices\nLet \\(A\\) and \\(B\\) be matrices of dimensions \\(r \\times c\\). We sum the matrices together element-wise. The matrices must be of exactly the same dimensions.\n$\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\\\ 1 & 1 \\end{bmatrix}\\]\n\n\\[\\begin{bmatrix} 7 & 1 \\\\  1 & 1 \\\\ 4 & 4 \\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix} 8 & 4 \\\\  3 & 5 \\\\ 5 & 5 \\end{bmatrix}\\]\n$\n\n\n# Adding matrices in R\nA <- matrix(c(1,3,2,4,1,1), byrow=3, ncol=2)\nB <- matrix(c(7,1,1,1,4,4), byrow=3, ncol=2)\n\nA +B\n\n     [,1] [,2]\n[1,]    8    4\n[2,]    3    5\n[3,]    5    5\n\n\n\n\n3.5 Multiplying matrix x vector\nLet \\(A\\) be an \\(r \\times c\\) matrix and ;et \\(B\\) be a column vector with \\(c\\) dimensions Note the number of elements in one dimension (here \\(c\\)) bust be the same.\n$\n\\[\\begin{bmatrix} a_{11} & a_{12} & \\dots & a_{1c} \\\\ a_{21} & a_{22} & \\dots & a_{2c} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{r1} & a_{r2} & \\dots & a_{rc} \\end{bmatrix}\\]\n\\[\\begin{bmatrix} b_{1} \\\\  b_{2} \\\\  \\vdots \\\\ b_{c} \\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix} a_{11} b_{1} + a_{12} b_{2} +  \\dots + a_{1c}b_{c} \\\\ a_{21} b_{1} + a_{22} b_{2} + \\dots + a_{2c} b_{c} \\\\ \\vdots  \\\\ a_{r1} b_{1} + a_{r2} b_{2} +  \\dots   + a_{rc} b_{c} \\end{bmatrix}\\]\n$\n\\(\\begin{bmatrix} 1 & 3 \\\\ 2 & 4 \\\\ 1 & 1 \\end{bmatrix} \\times \\begin{bmatrix} 7 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\cdot 7 + 3 \\cdot 1 \\\\ 2 \\cdot 7 + 4 \\cdot 1 \\\\ 1 \\cdot 7 + 1 \\cdot 1 \\end{bmatrix}\\begin{bmatrix} 10 \\\\ 18 \\\\ 8 \\end{bmatrix}\\)\n\n# Matrix x vector multiplication in R\nA <- matrix(c(1,3,2,4,1,1), byrow=3, ncol=2)\nC <- c(7,1)\n\n# NB the %*% syntax, correct for matrix x vector\nA %*% C\n\n     [,1]\n[1,]   10\n[2,]   18\n[3,]    8\n\n# NB this will also evaluate, but has a different result...\n# Can you tell what is going on here?\nA * C\n\n     [,1] [,2]\n[1,]    7    3\n[2,]    2   28\n[3,]    7    1\n\n\n\n\n3.6 Multiplying matrix x matrix\n(Here it gets tricky)\nLet \\(A\\) be an \\(r \\times c\\) matrix and \\(B\\) be a \\(c \\times t\\) matrix, where the number of columns in \\(A\\) is equal to the number of rows in \\(B\\).\n\n# Matrix x matrix multiplication in R\nA <- matrix(c(1, 3, 2, 2, 8, 9), ncol = 2)\nB <- matrix(c(5, 8, 4, 2), ncol = 2)\n\n# NB the %*% syntax\nA %*% B\n\n     [,1] [,2]\n[1,]   21    8\n[2,]   79   28\n[3,]   82   26\n\n\n\n\n3.7 Vectors as matrics\nVectors can be treated as matrices and in R can be coerced to matrix objects, where a column vector of length \\(r\\) becomes an \\(r \\times 1\\) matrix or a row vector of length \\(c\\) becomes a \\(1 \\times c\\) matrix\n\n# Vectors as matrices in R\n\n# Vanilla numeric vector\n(A <- c(4,5,8)); class(A)\n\n[1] 4 5 8\n\n\n[1] \"numeric\"\n\n# Column matrix\n(A <- matrix(c(4,5,8), nrow=3)); class(A)\n\n     [,1]\n[1,]    4\n[2,]    5\n[3,]    8\n\n\n[1] \"matrix\" \"array\" \n\n# Row matrix\n(A <- matrix(c(4,5,8), ncol=3)); class(A)\n\n     [,1] [,2] [,3]\n[1,]    4    5    8\n\n\n[1] \"matrix\" \"array\" \n\n\n\n\n3.8 Special matrics\n– Square matrix An n × n matrix\n– Symmetric matrix A is if \\(A = A^\\intercal\\).\n– 0-matrix A matrix with 0 on all entries, often written simply as 0.\n– 1-matrix A matrix with 1 on all entries, often written simply as J.\n– Diagonal matrix A square matrix with 0 on all off–diagonal entries and elements d1, d2, … , dn on the diagonal, often written diag{d1, d2, … , dn}\n– Identity matrix is one with with all 1s on the diagonal, denoted I and satisfies that IA = AI = A.\n\n# 0-matrix\nmatrix(0, nrow = 2, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n\n# 1-matrix\nmatrix(1, nrow = 2, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n\n# Diagonal matrix\ndiag(c(1, 2, 3))\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    2    0\n[3,]    0    0    3\n\n# Identity matrix\ndiag(1, 3)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n# Note what happens when diag() is applied to a matrix\n(D <- diag(c(4,3,5)))\n\n     [,1] [,2] [,3]\n[1,]    4    0    0\n[2,]    0    3    0\n[3,]    0    0    5\n\ndiag(D)\n\n[1] 4 3 5\n\n(A <- matrix(c(1,3,2,2,6,8,9,3,4), ncol = 3))\n\n     [,1] [,2] [,3]\n[1,]    1    2    9\n[2,]    3    6    3\n[3,]    2    8    4\n\ndiag(A)\n\n[1] 1 6 4\n\n\n\n\n3.9 Inverse of a matrix\nThe inverse of an \\(n × n\\) matrix \\(A\\) is the \\(n × n\\) matrix \\(B\\) (which is which when multiplied with A gives the identity matrix I. That is, \\(AB = BA = I\\).\nThus\n\\(B\\) is the inverse of \\(A\\), written as \\(B = A^{−1}\\) and\n\\(A\\) is the inverse of \\(B\\), written as \\(A = B^{−1}\\)\nNumeric example\n$ A =\n\\[\\begin{bmatrix} 1 & 3 \\\\  2 & 4 \\end{bmatrix}\\]\nB =\n\\[\\begin{bmatrix} -2 & 1.5 \\\\  1 & -0.5 \\end{bmatrix}\\]\n$\nWe can show \\(AB = BA = I\\), thus \\(B=A^{-1}\\)\n\n# Inverse of matrices\n\n(A <- matrix(c(1,3,2,4), ncol=2, byrow=T))\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n(B <- matrix(c(-2,1.5,1,-0.5), ncol=2, byrow=T))\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\nA%*%B\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\nB%*%A == diag(1,2)\n\n     [,1] [,2]\n[1,] TRUE TRUE\n[2,] TRUE TRUE\n\n\n– Only square matrices can have an inverse, but not all square matrices have an inverse. – When the inverse exists, it is unique. – Finding the inverse of a large matrix A is numerically complicated (but computers do it for us).\n\n# Solving the inverse of a matrix in R using solve()\n\n(A <- matrix(c(1,3,2,4), ncol=2, byrow=T))\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n(B <- solve(A))\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\n# Prove the rule\nA %*% B\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1"
  },
  {
    "objectID": "lab01-lin-alg.html#special-topics",
    "href": "lab01-lin-alg.html#special-topics",
    "title": "Lab 01 Linear alg.",
    "section": "4 Special topics",
    "text": "4 Special topics\n\n4.1 Solving linear equations\nMatrix math is related to math that can be used to solve linear equation systems. This is a very large topic and we will only briefly touch upon it, but it is core in statistics and in machine learning. We can sometimes ignore the details, but awareness of this area of math will likely be beneficial.\nConsider these two linear equations\n\\(x_1 + 3x_2 = 7\\)\n\\(2x_1 + 4x_2 = 10\\)\nWe can write this “system” of equations in matrix form, from which is derived the notation for statistical linear models. Let’s define the matrices \\(A\\), \\(x\\) and \\(b\\) as:\n\\(\\begin{bmatrix} 1 & 3 \\\\ 2 & 4 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 7 \\\\ 10 \\end{bmatrix}\\), i.e. \\(Ax = b\\)\nBecause \\(A^{-1}A = I\\) and \\(Ix=x\\):\n\\(x = A^{-1}b = \\begin{bmatrix} -2 & 1.5 \\\\ 1 & -0.5 \\end{bmatrix} \\begin{bmatrix} 7 \\\\ 10 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\\)\nThis way of thinking is the fountation of the linear model and we can exploit it to isolate and “solve” for the x values. E.g. we can isolate and solve for \\(x_2\\) as:\n\\(x_2 = \\frac{7}{3}-\\frac{1}{3}x_1\\), \\(x_2 = \\frac{10}{4}-\\frac{2}{4}x_1\\)\nNow we can graphically represent these equations, which are two lines and which demonstrate the solutions\n\n\n\n\n\nThe lines represent the solved equations above, and it can be seen that they cross at a single point, the solutions for \\(x_1\\) and \\(x_2\\), \\(x_1 = 1\\) and \\(x_2=2\\), respectively.\n\nA <- matrix(c(1, 2, 3, 4), ncol = 2)\nb <- c(7, 10)\n(x <- solve(A) %*% b)\n\n     [,1]\n[1,]    1\n[2,]    2\n\n\nWhile in this example we see exactly 1 solution, there are several possibilities in general:\n\nExactly one solution – when the lines intersect in one point\nNo solutions – when the lines are parallel but not identical\nInfinitely many solutions – when the lines coincide.\n\n\n\n4.2 Matrix equalities\nHere are a few additional properties of matrices\n\\((A + B)^\\intercal = A^\\intercal + B^\\intercal\\)\n\\((AB)^\\intercal = B^\\intercal A^\\intercal\\)\n\\(A(B + C) = AB + AC\\)\n\\(AB = AC 6) B = C\\)\nIn generel \\(AB \\neq BA\\)\n\\(AI = IA = A\\)\nIf \\(\\alpha\\) is a number then \\(\\alpha AB = A(\\alpha B)\\)\n\n\n4.3 Least squares\nConsider the following paired values\n\ndf <- data.frame(x=c(1,2,3,4,5),\n                 y=c(3.7, 4.2,4.9,5.7,6.0))\ndf\n\n  x   y\n1 1 3.7\n2 2 4.2\n3 3 4.9\n4 4 5.7\n5 5 6.0\n\n\nWe can plot these values and note that the relationship is approvimately linear (i.e., a straight line can be drawn that comes close to all the values)\n\n\n\n\n\nWe can notate the linear relationship between \\(x\\) and \\(y\\) with\n\\(y_i = \\beta_0 +\\beta_1x_i\\) for \\(i = 1, \\dots, 5\\)\nThis can be written in matrix form\n\\(y = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_5 \\end{bmatrix} \\approx \\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\vdots & \\vdots \\\\1 & x_5 \\\\ \\end{bmatrix} \\begin{bmatrix} \\beta_0 \\\\ \\beta_1\\end{bmatrix} = \\mathbf{X \\beta}\\)\nGiven that we have vectors \\(y\\) and \\(x\\), how can we find the vector \\(\\mathbf{\\beta}\\) to satisfy this equality such that \\(y=X \\beta\\)?\nActually, the answer is no because this would require the points to lie on an exactly straight line! However, it may be useful to find an estimate of \\(\\beta\\) such that \\(\\mathbf{X \\beta}\\) is “as close to \\(y\\) as possible”. Let’s call this estimate \\(\\hat{\\beta}\\)\nTo do this we would like to find \\(\\hat{\\beta}\\) that minimizes the equation\n\\(e=y- \\mathbf{X \\beta}\\)\nThe solution to this problem is the basis of linear regression and other linear statistical models:\n\\(\\hat{\\beta} = (X^\\intercal X)^{-1} X^\\intercal y\\)\n\ny <- c(3.7, 4.2,4.9,5.7,6.0)\nx <- c(1,2,3,4,5)\nX <- matrix(c(rep(1,5), x), ncol=2, byrow=F)\ncolnames(X) <- c('','x')\n\ny\n\n[1] 3.7 4.2 4.9 5.7 6.0\n\nX\n\n       x\n[1,] 1 1\n[2,] 1 2\n[3,] 1 3\n[4,] 1 4\n[5,] 1 5\n\n# this solves \"Beta hat\"\n# NB, the intercept and slope coeeficients for linear regression!\n(beta.hat <- solve(t(X) %*% X) %*% t(X) %*% y)\n\n  [,1]\n  3.07\nx 0.61"
  },
  {
    "objectID": "lab01-lin-alg.html#exercises",
    "href": "lab01-lin-alg.html#exercises",
    "title": "Lab 01 Linear alg.",
    "section": "5 Exercises",
    "text": "5 Exercises\n\n5.1 The bird table\nOn a sunny day, two tables are standing in an English country garden. On each table birds of unknown species are sitting having the time of their lives. A bird from the first table says to those on the second table: “Hi – if one of you come to our table then there will be the same number of us on each table”. “Yeah, right”, says a bird from the second table, “but if one of you comes to our table, then we will be twice as many on our table as on yours”.\nQuestion: How many birds are on each table?\n\nWrite up two equations with two unknowns\nSolve these equations using the methods you have learned from linear algebra\nSimply finding the solution by trial–and–error is invalid"
  },
  {
    "objectID": "lec00-module-intro.html#c7081-statistical-analysis-for-data-science",
    "href": "lec00-module-intro.html#c7081-statistical-analysis-for-data-science",
    "title": "c7081 Lec00 Module Introduction",
    "section": "C7081 Statistical Analysis for Data Science",
    "text": "C7081 Statistical Analysis for Data Science\n\nEd Harris"
  },
  {
    "objectID": "lec00-module-intro.html#section",
    "href": "lec00-module-intro.html#section",
    "title": "C7081-2022 Statistical analysis for data science",
    "section": "",
    "text": "C7081 Statistical Analysis for Data Science\nEd Harris"
  },
  {
    "objectID": "lec00-module-intro.html#module-overview",
    "href": "lec00-module-intro.html#module-overview",
    "title": "C7081-2022 Statistical analysis for data science",
    "section": "Module overview",
    "text": "Module overview\n\n\n\n\n“I am always ready to learn although I do not always like being taught.”\n\n-Winston Churchill"
  },
  {
    "objectID": "lec00-module-intro.html#module-overview-1",
    "href": "lec00-module-intro.html#module-overview-1",
    "title": "C7081-2022 Statistical analysis for data science",
    "section": "Module overview",
    "text": "Module overview\n\n\nOne week intensive format\nDaily catch-up meetings\nRecorded lectures, readings\nLabs are critical"
  },
  {
    "objectID": "lab00-welcome.html",
    "href": "lab00-welcome.html",
    "title": "Lab Welcome",
    "section": "",
    "text": "This is a simple activity with a few parts to help get you into the mindset of practicing working with data. We will be doing work to allow you to use some specific skills, but the real point of this exercise is to begin to think about beginning to take responsibility for information you construct using data."
  },
  {
    "objectID": "lab00-welcome.html#harper-adams-data-science",
    "href": "lab00-welcome.html#harper-adams-data-science",
    "title": "Lab Welcome",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab00-welcome.html#bmi-data",
    "href": "lab00-welcome.html#bmi-data",
    "title": "Lab Welcome",
    "section": "1 BMI data",
    "text": "1 BMI data\n\n\n\n\nBMI chart\n\n\n\nThe Body Mass Index (BMI) is a numerical scale intended as a rough guideline to body weight relative to body size. There are a number of assumptions underlying the scale, and the BMI is considered imperfect, but is in wide use.\nThe BMI is calculated thus:\n\\(BMI = \\frac{weight(Kg)}{height(m^2)}\\)\nYou can calculate your own BMI here"
  },
  {
    "objectID": "lab00-welcome.html#data-should-be-tidy",
    "href": "lab00-welcome.html#data-should-be-tidy",
    "title": "Lab Welcome",
    "section": "2 Data should be tidy",
    "text": "2 Data should be tidy\n\n\n\n\nData should be tidy, like your room\n\n\n\nThe concept of tidy data is popular and widely considered best practice. The concept has been summarized in a highly cited paper by Wickham (2014).\nThe essence of the Tidy Data concept is:\n\nSimple data structure, one observation per row\nSimple variable names (informative, short, no spaces, weird characters)\nData explanation or “Data Dictionary” present\nNo extraneous information (like figures, summaries) embedded with the data storage"
  },
  {
    "objectID": "lab00-welcome.html#exercises",
    "href": "lab00-welcome.html#exercises",
    "title": "Lab Welcome",
    "section": "3 Exercises",
    "text": "3 Exercises\n\n3.1 Make tidy data\nUse the following tab-delimited data files: bmi_f.txt bmi_m.txt\nThe data look like this:\n\n\n\nbmi_f.txt\n\n\n\nID, subject ID within each file\nsteps, # steps / wk past 16 weeks\nbmi, bmi measure\nsex is indicated implicitly by males and females data being separated in different files\n\nYour task:\n\nConvert the data to a tidy data format in a single .xlsx file\nDo this using only R code\nData dictionary may be added with code or “manually”\nWe will scrutinize and discuss\n\n\n\n3.2 Analyse BMI data\nConsider three specific hypotheses: \n\nthat there is a statistically significant difference in the average number of steps taken by men and women\nthat there is a negative correlation between the number of steps and the BMI for women\nthat this correlation is positive for men\n\n\nPerform analysis ~30 mins\nDo not speak to others\nWe will discuss of findings as a group\n\n\n\n3.3 Make a data report using markdown\n\nMarkdown is a language\nR markdown is “R flavoured Markdown”\nFormat a “dynamic” report using R Markdown\n\nThe task here is to create a very brief report of your BMI analysis and findings, using R Markdown. The point here is really just to practice markdown and think of how to communicate results to others.\nA markdown document is “freeform” ; the structure I suggest here is a minimal example for good practice.\nTitle + other details - descriptive title, set in the YAML (“YAML ain’t Markup Language”: recursive acronym…) header Summary of major findings - written LAST\nBackground - like the introduction section in a scientific paper. The most important part is a list of OBJECTIVES\nResults Graphs, stats results, terse, clear, technical style\nBibliography (if relevant) References are usually cited in Background, or possibly in Results if there are methods citations\n\nMake your own report (~45 mins)\nStart a new R Markdown document in RStudio, HTML output (NB pdf, word options)\nStructured your doc with the sections: Title, Summary, Background, Results, Bibliography\nThere are usually several “unseen” sections that may contain your R code in code chunks\nWe will discuss and critique resulting reports and code (~45 mins)"
  },
  {
    "objectID": "lab00-welcome.html#resources",
    "href": "lab00-welcome.html#resources",
    "title": "Lab Welcome",
    "section": "Resources",
    "text": "Resources\nR Bootcamp Markdown page"
  },
  {
    "objectID": "lab02-R-practice.html#resources",
    "href": "lab02-R-practice.html#resources",
    "title": "Lab 02 R practice",
    "section": "Resources",
    "text": "Resources\nHere are a few web resources for self learning if you wish to go farther"
  },
  {
    "objectID": "lab02-R-practice.html#harper-adams-data-science",
    "href": "lab02-R-practice.html#harper-adams-data-science",
    "title": "Lab 02 R practice",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab02-R-practice.html",
    "href": "lab02-R-practice.html",
    "title": "Lab 02 R practice",
    "section": "",
    "text": "The purpose of this lab is to practice some R basics that we will begin using right away. If you are already proficient in R and need no practice, feel free to skip ahead to the Exercises to test yourself."
  },
  {
    "objectID": "lab02-R-practice.html#basic-commands",
    "href": "lab02-R-practice.html#basic-commands",
    "title": "Lab 02 R practice",
    "section": "1 Basic commands",
    "text": "1 Basic commands\n\nc()\nR uses functions to perform operations. To run a function called funcname, we type funcname(input1, input2), where the inputs (or arguments) input1 and input2 tell R how to run the function. A function can have any number of inputs. For example, to create a vector of numbers, we use the function c() (for concatenate). Any numbers inside the parentheses are joined together. The following command instructs R to join together the numbers 1, 3, 2, and 5, and to save them as a vector named x. When we type x, it gives us back the vector.\n\nx <- c(1,3,2,5)\nx\n\n[1] 1 3 2 5\n\n\n\n\n<- value assignment\nWe can also “save things” (i.e. assign values) using = rather than <-, though the “arrow” syntax is the standard style in R:\n\nx = c(1,6,2)\nx\n\n[1] 1 6 2\n\ny = c(1,4,3) # why doesn't this \"print out\"?\n\n\n\nlength()\nHitting the up arrow multiple times will display the previous commands, which can then be edited. This is useful since one often wishes to repeat a similar command. In addition, typing ?funcname will always cause R to open a new help file window with additional information about the function funcname. We can tell R to add two sets of numbers together. It will then add the first number from x to the first number from y, and so on. However, x and y should be the same length. We can check their length using the length() function.\n\n\nls() , rm()\nThe ls() function allows us to look at a list of all of the objects, such as data and functions, that we have saved so far. The rm() function can be used to delete any that we don’t want.\n\nls()\n\n[1] \"x\" \"y\"\n\nrm(x,y)\nls()\n\ncharacter(0)\n\n\nIt’s also possible to remove all objects at once without explicitly naming them (handy of you have more than few data objects in you Global Environment):\n\nx = c(1,6,2)\ny = c(1,4,3)\nls()\n\n[1] \"x\" \"y\"\n\nrm(list=ls()) # do you see what the 'list' argument does here?\nls()\n\ncharacter(0)\n\n\n\n\nmatrix()\nThe matrix() function is used to create a matrix of numbers. Before we use the matrix() function, we can learn more about it to examine the arguments:\n\n# ?matrix\n\nThe help ﬁle reveals that the matrix() function takes a number of inputs, but for now we focus on the ﬁrst three: the data (the entries in the matrix), the number of rows, and the number of columns. First, we create a simple matrix.\n\nx <-  matrix( data=c(1 ,2 ,3 ,4) , nrow =2 , ncol =2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nNote that we could just as well omit explicitly typing data=, nrow=, and ncol= in the matrix() command above: that is, we could just type:\n\nx <- matrix ( c(1 ,2 ,3 ,4) ,2 ,2)\n\nand this would have the same effect. However, it can sometimes be useful to specify the names of the arguments passed in, since otherwise R will assume that the function arguments are passed into the function in the same order that is given in the function’s help ﬁle. As this example illustrates, by default R creates matrices by successively ﬁlling in columns. Alternatively, the byrow=TRUE option can be used to populate the matrix in order of the rows.\n\nx <- matrix ( c(1 ,2 ,3 ,4) ,2 ,2, byrow=TRUE)\n\n\n\nsqrt() sqare root\nNotice that in the above command we did not assign the matrix to a value such as x. In this case the matrix is printed to the screen but is not saved for future calculations. The sqrt() function returns the square root of each element of a vector or matrix. The command x^2 raises each element of x to the power 2; any powers are possible, including fractional or negative powers.\n\nsqrt(x)\n\n         [,1]     [,2]\n[1,] 1.000000 1.414214\n[2,] 1.732051 2.000000\n\nx^2\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    9   16\n\n\n\n\nrnorm(), cor() random Gaussian numbers, correlation\nThe rnorm() function generates a vector of random normal variables, with ﬁrst argument n the sample size. Each time we call this function, we will get a diﬀerent answer. Here we create two correlated sets of numbers, x and y, and use the cor() function to compute the correlation between them.\n\nx <- rnorm(50)\ny <- x+ rnorm(50 , mean =50 , sd =.1)\ncor(x, y)\n\n[1] 0.995579\n\n\n\n\nset.seed makes ‘pseudo-random’ events repeatable\nBy default, rnorm() creates standard normal random variables with a mean of 0 and a standard deviation of 1. However, the mean and standard devi- ation can be altered using the mean and sd arguments, as illustrated above. Sometimes we want our code to reproduce the exact same set of random numbers; we can use the set.seed() function to do this. The set.seed() function takes an (arbitrary) integer argument.\n\nrnorm(5); rnorm(5)\n\n[1]  0.32107626  1.84581269  1.65005775  0.73101927 -0.02408517\n\n\n[1]  0.11445028  1.75470787  0.56345649  1.11151246 -0.08037817\n\nset.seed(42); rnorm(5); set.seed(42); rnorm(5)\n\n[1]  1.3709584 -0.5646982  0.3631284  0.6328626  0.4042683\n\n\n[1]  1.3709584 -0.5646982  0.3631284  0.6328626  0.4042683\n\n\nWe will endeavor to use set.seed() throughout the labs whenever we perform calculations involving random quantities. In general this should allow the user to reproduce the results. However, it should be noted that as new versions of R become available discrepancies may form between the labs and the output from R.\n\n\nmean(), sd(), and var()\nThe mean() and var() functions can be used to compute the mean and variance of a vector of numbers. Applying sqrt() to the output of var() will give the standard deviation. Or we can simply use the sd() function.\n\nset.seed(3)\ny <- rnorm(100, 10, 1)\nmean(y)\n\n[1] 10.01104\n\nvar(y)\n\n[1] 0.7328675\n\nsqrt(y)\n\n  [1] 3.006338 3.115682 3.202934 2.974537 3.193084 3.167037 3.175755 3.334158\n  [9] 2.963299 3.356690 3.042239 2.978050 3.046907 3.201976 3.186228 3.113253\n [17] 3.007820 3.058064 3.350271 3.193714 3.069449 3.009601 3.129900 2.886785\n [25] 3.084728 3.042849 3.340751 3.318443 3.150860 2.977116 3.301609 3.294203\n [33] 3.275319 3.276660 3.106102 3.271928 3.361601 3.168320 3.003451 3.285386\n [41] 3.284282 3.112802 3.420363 3.034041 3.216899 2.781115 3.136526 3.336295\n [49] 3.089410 3.016759 3.275185 3.031593 3.204229 2.874498 2.930627 3.089733\n [57] 2.994079 3.370778 3.304157 3.035598 3.251695 3.304269 3.202544 3.217447\n [65] 3.342804 3.085313 3.095347 3.309851 2.951439 3.191582 3.157321 3.235289\n [73] 3.320271 3.204272 3.198723 3.278352 3.349189 3.222322 3.001991 3.137379\n [81] 3.425717 3.106075 3.269349 3.350284 3.285467 3.161265 3.196741 3.018863\n [89] 3.231062 3.018876 3.024265 3.001667 3.057633 3.324748 3.099858 3.151097\n [97] 3.088357 3.246676 3.306302 3.129014\n\nsd(y)\n\n[1] 0.8560768"
  },
  {
    "objectID": "lab02-R-practice.html#basic-graphics",
    "href": "lab02-R-practice.html#basic-graphics",
    "title": "Lab 02 R practice",
    "section": "2 Basic graphics",
    "text": "2 Basic graphics\n\nplot()\nThe plot() function is the primary way to plot data in R. For instance, plot(x,y) produces a scatterplot of the numbers in x versus the numbers in y. There are many additional options that can be passed in to the plot() function. For example, passing in the argument xlab will result in a label on the x-axis. To ﬁnd out more information about the plot() function, don’t forget to use ?plot.\n\nx <- rnorm(100)\ny <- rnorm(100)\nplot(x,y) # yuck\n\n\n\nplot(x,y, xlab=\" this is the x- axis\", \n     ylab =\" this is the y - axis\", \n     main =\" Plot of X vs Y \") # better\n\n\n\n\n\n\nOutput functions pdf(), png(), jpg()\nWe will often want to save the output of an R plot. The command that we use to do this will depend on the ﬁle type that we would like to create. For instance, to create a pdf, we use the pdf() function, and to create a jpeg, we use the jpeg() function, png(), etc.\n\n# This code will output a graph file to your working directory\npng(\"MyFigure.png\") # think of this as opening the file\nplot(x, y, pch=16, col =\"green\") # writing something for that file\ndev.off() # turning off the output to file\n\npng \n  2 \n\n\nThe function dev.off() indicates to R that we are done creating the plot. Alternatively, we can simply copy the plot window and paste it into an appropriate ﬁle type, such as a Word document.\n\n\nseq()\nThe function seq() can be used to create a sequence of numbers. For instance, seq(a,b) makes a vector of integers between a and b. There are many other options: for instance, seq(0,1,length=10) makes a sequence of 10 numbers that are equally spaced between 0 and 1. Typing 3:11 is a shorthand for seq(3,11) for integer arguments.\n\nx <- seq(1,10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx <- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx <- seq(-pi, pi, length = 50)\nx\n\n [1] -3.14159265 -3.01336438 -2.88513611 -2.75690784 -2.62867957 -2.50045130\n [7] -2.37222302 -2.24399475 -2.11576648 -1.98753821 -1.85930994 -1.73108167\n[13] -1.60285339 -1.47462512 -1.34639685 -1.21816858 -1.08994031 -0.96171204\n[19] -0.83348377 -0.70525549 -0.57702722 -0.44879895 -0.32057068 -0.19234241\n[25] -0.06411414  0.06411414  0.19234241  0.32057068  0.44879895  0.57702722\n[31]  0.70525549  0.83348377  0.96171204  1.08994031  1.21816858  1.34639685\n[37]  1.47462512  1.60285339  1.73108167  1.85930994  1.98753821  2.11576648\n[43]  2.24399475  2.37222302  2.50045130  2.62867957  2.75690784  2.88513611\n[49]  3.01336438  3.14159265"
  },
  {
    "objectID": "lab02-R-practice.html#special-plots",
    "href": "lab02-R-practice.html#special-plots",
    "title": "Lab 02 R practice",
    "section": "3 Special plots",
    "text": "3 Special plots\n\ncontour() plot\nWe will now create some more sophisticated plots. The contour() function produces a contour plot in order to represent three-dimensional data; it is like a topographical map. It takes three arguments:\n\nA vector of the x values (the ﬁrst dimension),\nA vector of the y values (the second dimension), and\nA matrix whose elements correspond to the z value (the third dimension) for each pair of (x,y) coordinates.\n\nAs with the plot() function, there are many other inputs that can be used to ﬁne tune the output of the contour() function. To learn more about these, take a look at the help ﬁle by typing ?contour.\n\n# don't worry too much about this code, but can you figure out what it does?\n\nx <- y <- 1:10\nf <- outer(x,y, function(x,y) cos(y)/(1+x^2))\ncontour(x,y,f)\n\n\n\nfa <- ( f- t(f))/2\ncontour (x,y, fa , nlevels = 15)\n\n\n\n\n\n\nimage() and persp()\nThe image() function works the same way as contour(), except that it produces a color-coded plot whose colors depend on the z value. This is known as a heatmap, and is sometimes used to plot temperature in weather forecasts. Alternatively, persp() can be used to produce a three-dimensional plot. The arguments theta and phi control the angles at which the plot is viewed.\n\nimage(x, y, fa)\n\n\n\npersp(x, y, fa)\n\n\n\npersp(x, y, fa, theta =30)\n\n\n\npersp(x, y, fa, theta =30, phi = 20) # not enough\n\n\n\npersp(x, y, fa, theta =30, phi = 70) # too much\n\n\n\npersp(x, y, fa, theta =30, phi = 40) # juust right"
  },
  {
    "objectID": "lab02-R-practice.html#indexing-data",
    "href": "lab02-R-practice.html#indexing-data",
    "title": "Lab 02 R practice",
    "section": "4 Indexing data",
    "text": "4 Indexing data\n\nIndexing values\nWe often wish to examine part of a set of data. Suppose that our data is stored in the matrix A.\n\nA <- matrix(1:16, 4, 4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\nThen submitting:\n\nA[2,3]\n\n[1] 10\n\n\nwill select the element corresponding to the second row and the third co umn. The ﬁrst number after the open-bracket symbol [ always refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by providing vectors as the indices.\n\nA[c(1,3), c(2,4)]\n\n     [,1] [,2]\n[1,]    5   13\n[2,]    7   15\n\nA[1:3, 2:4]\n\n     [,1] [,2] [,3]\n[1,]    5    9   13\n[2,]    6   10   14\n[3,]    7   11   15\n\nA[1:2,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n\nA[,1:2]\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n\nThe last two examples include either no index for the columns or no index for the rows. These indicate that R should include all columns or all rows, respectively. R treats a single row or column of a matrix as a vector.\n\nA[1,]\n\n[1]  1  5  9 13\n\n\nThe use of a negative sign - in the index tells R to keep all rows or columns except those indicated in the index.\n\nA[-c(1,3),]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n\nA[-c(1 ,3) ,-c(1 ,3 ,4)]\n\n[1] 6 8\n\n\n\n\ndim()\nThe dim() function outputs the number of rows followed by the number of columns of a given matrix.\n\ndim(A)\n\n[1] 4 4"
  },
  {
    "objectID": "lab02-R-practice.html#data-operations",
    "href": "lab02-R-practice.html#data-operations",
    "title": "Lab 02 R practice",
    "section": "4 Data operations",
    "text": "4 Data operations\n\nIndexing values\nWe often wish to examine part of a set of data. Suppose that our data is stored in the matrix A.\n\nA <- matrix(1:16, 4, 4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\nThen submitting:\n\nA[2,3]\n\n[1] 10\n\n\nwill select the element corresponding to the second row and the third co umn. The ﬁrst number after the open-bracket symbol [ always refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by providing vectors as the indices.\n\nA[c(1,3), c(2,4)]\n\n     [,1] [,2]\n[1,]    5   13\n[2,]    7   15\n\nA[1:3, 2:4]\n\n     [,1] [,2] [,3]\n[1,]    5    9   13\n[2,]    6   10   14\n[3,]    7   11   15\n\nA[1:2,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n\nA[,1:2]\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n\nThe last two examples include either no index for the columns or no index for the rows. These indicate that R should include all columns or all rows, respectively. R treats a single row or column of a matrix as a vector.\n\nA[1,]\n\n[1]  1  5  9 13\n\n\nThe use of a negative sign - in the index tells R to keep all rows or columns except those indicated in the index.\n\nA[-c(1,3),]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n\nA[-c(1 ,3) ,-c(1 ,3 ,4)]\n\n[1] 6 8\n\n\n\n\ndim()\nThe dim() function outputs the number of rows followed by the number of columns of a given matrix.\n\ndim(A)\n\n[1] 4 4\n\n\n\n\nLoading data\nFor most analyses, the ﬁrst step involves importing a data set into R. The read.table() function is one of the primary ways to do this. The help ﬁle contains details about how to use this function. We can use the function write.table() to export data.\nBefore attempting to load a data set, we must make sure that R knows to search for the data in the proper directory. For example on a Windows system one could select the directory using the Change dir... option under the File menu. However, the details of how to do this depend on the operating system (e.g. Windows, Mac, Unix) that is being used.\nHere you will begin by loading in the Auto data set, which is part of the R library {ISLR2}, but to illustrate the read.table() function we load it now from a text ﬁle. The following command will load the Auto.data ﬁle into R and store it as an object called Auto, in a format referred to as a data frame.\n\n\nAuto data\nDownload the Auto.csv data file\nOnce the data has been loaded, the fix() function can be used to view it in a spreadsheet like window. However, the window must be closed before further R commands can be entered.\n\n# Your code may look similar\n# Auto <- read.csv(\"Auto.csv\")\n# fix(Auto)\n\nPeek at the data (note the view may wrap around the lines)\n\nNote that data like these are usually simply a text ﬁle, which you could alternatively open on your computer using a standard text editor. It is often a good idea to view a data set using a text editor or other software such as Excel before loading it into R…\nThis particular data set has probably not loaded correctly for you on the first try, because\n\nR has assumed that the variable names are part of the data and so has included them in the ﬁrst row.\nThe data set also includes a number of missing observations, indicated by a question mark ?.\nThere is a problematic character (at least one…) in the name variable on row 12.\n\nMissing values are a common occurrence in real data sets. Using the argument header=T (or header=TRUE) in the read.table() function tells R that the ﬁrst line of the ﬁle contains the variable names, and using the option na.strings tells R that any time it sees a particular character or set of characters (such as a question mark), it should be treated as a missing element of the data matrix.\n\n# try this\n# Auto <- read.csv(\"data/Auto.csv\", sep = ',', header = T , na.strings = \"?\")\n# fix(Auto)\n\nOnce the data are loaded correctly\n\n# try this\n\n# dim(Auto)\n# Auto[1:4, ]\n# names(Auto)\n\n\n\nGraphical and numerical summary\nWe can use the plot() function to produce scatterplots of the quantitative variables. However, simply typing the variable names will produce an error message, because R does not know to look inside the Auto data object for those variables.\n\n\n\n\n# try this\n# plot(cylinders, mpg) #error\n# Error in plot(cylinders, mpg) : object 'cylinders' not found\n\n\nplot( Auto$cylinders,  Auto$mpg )\n\n\n\n\n\n\nattach()\nTo refer to a variable explicitly, we can type the data set and the variable name joined with a $ (cash) symbol. Alternatively, we can use the attach() function in order to tell R to make the variables in this data frame available by name.\n\nattach(Auto)\nplot(cylinders, mpg)\n\n\n\n\nThe cylinders variable is stored as a numeric vector, so R has treated it as quantitative. However, since there are only a small number of possible values for cylinders, one may prefer to treat it as a qualitative variable. The as.factor() function converts quantitative variables into qualitative variables.\n\ncylinders <- as.factor(cylinders)\n\nIf a variable plotted on the x-axis is categorial, then boxplots will automatically be produced by the plot() function. As usual, a number of options can be speciﬁed in order to customize the plots.\n\nplot(cylinders, mpg)\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\") # Ed's favourite R colour\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\", varwidth = T)\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\", varwidth = T , horizontal = T)\n\n\n\nplot(cylinders, mpg, col =\"goldenrod\", varwidth = T , \n     xlab=\"cylinders\", ylab =\"MPG\")\n\n\n\n\n\n\nhist()\nThe hist() function can be used to plot a histogram. Note that indexing the base color pallette numerically is possible, such that col=2 has the same effect as col=\"red\".\n\nhist(mpg)\n\n\n\nhist(mpg, col = 2)\n\n\n\nhist(mpg, col = 2, breaks = 15)\n\n\n\n\n\n\npairs()\nThe pairs() function creates a scatterplot matrix i.e. a scatterplot for every pair of variables for any given data set. We can also produce scatterplots for just a subset of the variables.\n\npairs(~ mpg + displacement + horsepower + weight + acceleration, Auto )\n\n\n\n\n\n\nidentify()\nIn conjunction with the plot() function, identify() provides a useful interactive method for identifying the value for a particular variable for points on a plot. We pass in three arguments to identify(): the x-axis variable, the y-axis variable, and the variable whose values we would like to see printed for each point. Then clicking on a given point in the plot will cause R to print the value of the variable of interest. Right-clicking on the plot will exit the identify() function (control-click on a Mac). The numbers printed under the identify() function correspond to the rows for the selected points.\n\nplot(horsepower, mpg)\n\n\n\n# this only works on your local machine - try it\n# identify(horsepower, mpg, name)\n\n\n\nsummary()\nThe summary() function produces a numerical summary of each variable in a particular data set.\n\nsummary(Auto)\n\n      mpg          cylinders      displacement     horsepower        weight    \n Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 46.0   Min.   :1613  \n 1st Qu.:17.00   1st Qu.:4.000   1st Qu.:105.0   1st Qu.: 75.0   1st Qu.:2225  \n Median :22.75   Median :4.000   Median :151.0   Median : 93.5   Median :2804  \n Mean   :23.45   Mean   :5.472   Mean   :194.4   Mean   :104.5   Mean   :2978  \n 3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:275.8   3rd Qu.:126.0   3rd Qu.:3615  \n Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :230.0   Max.   :5140  \n                                                                               \n  acceleration        year           origin                      name    \n Min.   : 8.00   Min.   :70.00   Min.   :1.000   amc matador       :  5  \n 1st Qu.:13.78   1st Qu.:73.00   1st Qu.:1.000   ford pinto        :  5  \n Median :15.50   Median :76.00   Median :1.000   toyota corolla    :  5  \n Mean   :15.54   Mean   :75.98   Mean   :1.577   amc gremlin       :  4  \n 3rd Qu.:17.02   3rd Qu.:79.00   3rd Qu.:2.000   amc hornet        :  4  \n Max.   :24.80   Max.   :82.00   Max.   :3.000   chevrolet chevette:  4  \n                                                 (Other)           :365  \n\n\nFor qualitative variables such as name, R will list the number of observations that fall in each category. We can also produce a summary of just a single variable.\n\nsummary(mpg)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.00   17.00   22.75   23.45   29.00   46.60 \n\n\n\n\nEnding your R session\nOnce we have ﬁnished using R, we type q() in order to shut it down, or quit. When exiting R, we have the option to save the current workspace so that all objects (such as data sets) that we have created in this R session will be available next time. Before exiting R, we may want to save a record of all of the commands that we typed in the most recent session; this can be accomplished using the savehistory() function. Next time we enter R, we can load that history using the loadhistory() function (useful in some circumstances)."
  },
  {
    "objectID": "lab03-lin-reg.html#exercises",
    "href": "lab03-lin-reg.html#exercises",
    "title": "Lab 03 Linear regression",
    "section": "4 Exercises",
    "text": "4 Exercises\n\nExercise 1\nThe following questions involve the use of simple linear regression on the Auto data set.\n\n1.1\nUse the lm() function to perform a simple linear regression with mpg as the response and horsepower as the predictor. Use the summary() function to print the results. Comment on the output. For example:\n\nIs there a relationship between the predictor and the response?\nHow strong is the relationship between the predictor and the response?\nIs the relationship between the predictor and the response positive or negative?\nWhat is the predicted mpg associated with a horsepower of 98?\nWhat are the associated 95% confidence and prediction intervals?\n\n\n\n1.2\nPlot the response and the predictor. Use the abline() function to display the least squares regression line.\n\n\n1.3\nUse the plot() function to produce diagnostic plots of the least squares regression fit. Comment on any problems you see with the fit.\n\nThe following questions involve the use of simple linear regression on the Auto data set.\n\n\n1.4\nProduce a scatterplot matrix which includes all of the variables in the data set.\n\n\n1.5\nCompute the matrix of correlations between the variables using the function cor(). You will need to exclude the name variable, which is qualitative.\n\n\n1.6\nUse the lm() function to perform a multiple linear regression with mpg as the response and all other variables except name as the predictors. Use the summary() function to print the results. Comment on the output.\n\nIs there a relationship between the predictors and the re- sponse?\nWhich predictors appear to have a statistically significant relationship to the response?\nWhat does the coeﬃcient for the year variable suggest?\n\n\n\n1.7\nUse the plot() function to produce diagnostic plots of the linear regression fit. Comment on any problems you see with the fit. Do the residual plots suggest any unusually large outliers? Does the leverage plot identify any observations with unusually high leverage?\n\n\n1.8\nUse the * and : symbols to fit linear regression models with interaction eﬀects. Do any interactions appear to be statistically significant?\n\n\n1.9\nTry a few different transformations of the variables, such as log(X), X, X^2. Comment on your findings."
  },
  {
    "objectID": "lab03-lin-reg.html#resources",
    "href": "lab03-lin-reg.html#resources",
    "title": "Lab 03 Linear regression",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "lab03-lin-reg.html#harper-adams-data-science",
    "href": "lab03-lin-reg.html#harper-adams-data-science",
    "title": "Lab 03 Linear regression",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab03-lin-reg.html",
    "href": "lab03-lin-reg.html",
    "title": "Lab 03 Linear regression",
    "section": "",
    "text": "The library() function is used to load libraries, or groups of functions and data sets that are not included in the base R distribution. Basic functions that perform least squares linear regression and other simple analyses come standard with the base distribution, but more exotic functions require additional libraries. Here we load the {MASS} package, which is a very large collection of data sets and functions. We also load the {ISLR} package, which includes the data sets associated with James et al. 2001.\n\nlibrary(MASS)\nlibrary(ISLR)\n\nWarning: package 'ISLR' was built under R version 4.1.3\n\n\nIf you receive an error message when loading these libraries, it likely indicates that the corresponding library has not yet been installed on your system. Some libraries, such as {MASS}, come with R and do not need to be separately installed on your computer. However, other packages, such as {ISLR}, must be downloaded the ﬁrst time they are used. This can be done directly from within R. For example, on a Windows system, select the Install package option under the Packages tab. After you select any mirror site, a list of available packages will appear. Simply select the package you wish to install and R will automatically download the package. Alternatively, this can be done at the R command line via install.packages(\"ISLR\"). This installation only needs to be done the ﬁrst time you use a package. However, the library() function must be called each time you wish to use a given package.\n\n\n\nThe {MASS} library contains the Boston data set, which records medv (median house value) for 506 neighborhoods around the US city of Boston. We will seek to predict medv using 13 predictors such as rm (average number of rooms per house), age (average age of houses), and lstat (percent of households with low socioeconomic status).\n\nnames(Boston)\n\n [1] \"crim\"    \"zn\"      \"indus\"   \"chas\"    \"nox\"     \"rm\"      \"age\"    \n [8] \"dis\"     \"rad\"     \"tax\"     \"ptratio\" \"black\"   \"lstat\"   \"medv\"   \n\nhead(Boston)\n\n     crim zn indus chas   nox    rm  age    dis rad tax ptratio  black lstat\n1 0.00632 18  2.31    0 0.538 6.575 65.2 4.0900   1 296    15.3 396.90  4.98\n2 0.02731  0  7.07    0 0.469 6.421 78.9 4.9671   2 242    17.8 396.90  9.14\n3 0.02729  0  7.07    0 0.469 7.185 61.1 4.9671   2 242    17.8 392.83  4.03\n4 0.03237  0  2.18    0 0.458 6.998 45.8 6.0622   3 222    18.7 394.63  2.94\n5 0.06905  0  2.18    0 0.458 7.147 54.2 6.0622   3 222    18.7 396.90  5.33\n6 0.02985  0  2.18    0 0.458 6.430 58.7 6.0622   3 222    18.7 394.12  5.21\n  medv\n1 24.0\n2 21.6\n3 34.7\n4 33.4\n5 36.2\n6 28.7\n\n\n\n\n\nTo ﬁnd out more about the data set, we can type ?Boston. We will start by using the lm() function to ﬁt a simple linear regression model, with medv as the response and lstat as the predictor. The basic syntax is lm(y∼x,data), where y is the response, x is the predictor, and data is the data set in which these two variables are kept.\n\n# try this\n# lm.fit <- lm(medv~lstat)\n\nThe command causes an error because R does not know where to ﬁnd the variables medv and lstat. The next line tells R that the variables are in Boston. If we attach Boston, the ﬁrst line would work ﬁne because R now recognizes the variables. However, the data argument works here too.\n\nlm.fit <- lm(medv~lstat , data = Boston)\nattach(Boston)\nlm.fit <- lm(medv~lstat)\n\nIf we submit lm.fit, some basic information about the model is output. For more detailed information, we use summary(lm.fit). This gives us p-values and standard errors for the coeffcients, as well as the R2 statistic and F-statistic for the model.\n\nlm.fit\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nCoefficients:\n(Intercept)        lstat  \n      34.55        -0.95  \n\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.168  -3.990  -1.318   2.034  24.500 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 34.55384    0.56263   61.41   <2e-16 ***\nlstat       -0.95005    0.03873  -24.53   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.216 on 504 degrees of freedom\nMultiple R-squared:  0.5441,    Adjusted R-squared:  0.5432 \nF-statistic: 601.6 on 1 and 504 DF,  p-value: < 2.2e-16\n\nnames(lm.fit)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\ncoef(lm.fit)\n\n(Intercept)       lstat \n 34.5538409  -0.9500494 \n\n\nThe predict() function can be used to produce conﬁdence intervals and prediction intervals for the prediction of medv for a given value of lstat.\n\npredict(lm.fit, data.frame(lstat = ( c(5, 10, 15) )),\n        interval = \"confidence\") \n\n       fit      lwr      upr\n1 29.80359 29.00741 30.59978\n2 25.05335 24.47413 25.63256\n3 20.30310 19.73159 20.87461\n\npredict(lm.fit, data.frame(lstat = ( c(5, 10, 15) )),\n        interval = \"prediction\") \n\n       fit       lwr      upr\n1 29.80359 17.565675 42.04151\n2 25.05335 12.827626 37.27907\n3 20.30310  8.077742 32.52846\n\n\nFor instance, the 95% conﬁdence interval associated with a lstat value of 10 is (24.47, 25.63), and the 95% prediction interval is (12.828, 37.28). As expected, the conﬁdence and prediction intervals are centered around the same point (a predicted value of 25.05 for medv when lstat equals 10), but the latter are substantially wider.\nWe will now plot medv and lstat along with the least squares regression line using the plot() and abline() functions.\n\nplot(lstat , medv)\nabline(lm.fit)\n\n\n\n\nThere is some visual evidence for non-linearity in the relationship between lstat and medv. We will explore this issue later in this lab.\nThe abline() function can be used to draw any line, not just the least squares regression line. To draw a line with intercept a and slope b, we type abline(a,b). Below we experiment with some additional settings for plotting lines and points. The lwd=3 command causes the width of the regression line to be increased by a factor of 3; this works for the plot() and lines() functions also. We can also use the pch option to create different plotting symbols.\n\nplot(lstat , medv)\nabline(lm.fit, lwd = 3)\n\n\n\nplot(lstat , medv)\nabline(lm.fit, lwd = 3, col = \"red\")\n\n\n\nplot(lstat, medv, col = \"red\")\n\n\n\nplot(lstat, medv, pch = 20)\n\n\n\nplot(lstat, medv, pch =\"+\")\n\n\n\nplot(1:20, 1:20, pch = 1:20)\n\n\n\n\n\n\n\nNext we examine some diagnostic plots (discussed in Section 3.3.3 of James et al. 2021). Four diagnostic plots are automatically produced by applying the plot() function directly to the output from lm(). In general, this command will produce one plot at a time, and hitting Enter will generate the next plot. However, it is often convenient to view all four plots together. We can achieve this by using the par() function, which tells R to split the display screen into separate panels so that multiple plots can be viewed simultaneously. For example, par(mfrow=c(2,2)) divides the plotting region into a 2 × 2 grid of panels.\n\npar(mfrow = c(2, 2))\nplot(lm.fit)\n\n\n\n\nAlternatively, we can compute the residuals from a linear regression ﬁt using the residuals() function. The function rstudent() will return the studentized residuals, and we can use this function to plot the residuals against the ﬁtted values.\n\npar(mfrow = c(1, 3))\nplot(predict(lm.fit), residuals(lm.fit))\nplot(predict(lm.fit), rstudent(lm.fit))\nplot(residuals(lm.fit), rstudent(lm.fit)) # hmm actually these are the same\n\n\n\n\nOn the basis of the residual plots, there is some evidence of non-linearity. Leverage statistics can be computed for any number of predictors using the hatvalues() function.\n\npar(mfrow = c(1, 1))\nplot(hatvalues(lm.fit))\n\n\n\nwhich.max(hatvalues(lm.fit)) \n\n375 \n375 \n\n\nThe which.max() function identiﬁes the index of the largest element of a vector. In this case, it tells us which observation has the largest leverage statistic."
  },
  {
    "objectID": "lab03-lin-reg.html#multiple-regression",
    "href": "lab03-lin-reg.html#multiple-regression",
    "title": "Lab 03 Linear regression",
    "section": "2 Multiple regression",
    "text": "2 Multiple regression\nIn order to ﬁt a multiple linear regression model using least squares, we again use the lm() function. The syntax lm(y∼x1+x2+x3) is used to ﬁt a model with three predictors, x1, x2, and x3. The summary() function now outputs the regression coeﬃcients for all the predictors.\n\nlm.fit <- lm(medv ~ lstat + age, data = Boston )\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat + age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.981  -3.978  -1.283   1.968  23.158 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 33.22276    0.73085  45.458  < 2e-16 ***\nlstat       -1.03207    0.04819 -21.416  < 2e-16 ***\nage          0.03454    0.01223   2.826  0.00491 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.173 on 503 degrees of freedom\nMultiple R-squared:  0.5513,    Adjusted R-squared:  0.5495 \nF-statistic:   309 on 2 and 503 DF,  p-value: < 2.2e-16\n\n\nThe Boston data set contains 13 variables, and so it would be cumbersome to have to type all of these in order to perform a regression using all of the predictors. Instead, we can use the following short-hand:\n\nlm.fit <- lm(medv ~ ., data = Boston)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ ., data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.595  -2.730  -0.518   1.777  26.199 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  3.646e+01  5.103e+00   7.144 3.28e-12 ***\ncrim        -1.080e-01  3.286e-02  -3.287 0.001087 ** \nzn           4.642e-02  1.373e-02   3.382 0.000778 ***\nindus        2.056e-02  6.150e-02   0.334 0.738288    \nchas         2.687e+00  8.616e-01   3.118 0.001925 ** \nnox         -1.777e+01  3.820e+00  -4.651 4.25e-06 ***\nrm           3.810e+00  4.179e-01   9.116  < 2e-16 ***\nage          6.922e-04  1.321e-02   0.052 0.958229    \ndis         -1.476e+00  1.995e-01  -7.398 6.01e-13 ***\nrad          3.060e-01  6.635e-02   4.613 5.07e-06 ***\ntax         -1.233e-02  3.760e-03  -3.280 0.001112 ** \nptratio     -9.527e-01  1.308e-01  -7.283 1.31e-12 ***\nblack        9.312e-03  2.686e-03   3.467 0.000573 ***\nlstat       -5.248e-01  5.072e-02 -10.347  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.745 on 492 degrees of freedom\nMultiple R-squared:  0.7406,    Adjusted R-squared:  0.7338 \nF-statistic: 108.1 on 13 and 492 DF,  p-value: < 2.2e-16\n\n\nWe can access the individual components of a summary object by name (type ?summary.lm to see what is available). Hence summary(lm.fit)$r.sq gives us the R2, and summary(lm.fit)$sigma gives us the RSE. The vif() function, part of the {car} package, can be used to compute variance inﬂation factors. Most VIF’s are low to moderate for this data (<= 4.0 is considered low). The {car} package is not part of the base R installation so it must be downloaded the ﬁrst time you use it via the install.packages option in R.\n\nlibrary(car)\n\nWarning: package 'car' was built under R version 4.1.1\n\n\nLoading required package: carData\n\nvif(lm.fit)\n\n    crim       zn    indus     chas      nox       rm      age      dis \n1.792192 2.298758 3.991596 1.073995 4.393720 1.933744 3.100826 3.955945 \n     rad      tax  ptratio    black    lstat \n7.484496 9.008554 1.799084 1.348521 2.941491 \n\n\nWhat if we would like to perform a regression using all of the variables but one? For example, in the above regression output, age has a high p-value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age.\n\nlm.fit1 <- lm(medv ~ . -age, data = Boston )\nsummary(lm.fit1 )\n\n\nCall:\nlm(formula = medv ~ . - age, data = Boston)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.6054  -2.7313  -0.5188   1.7601  26.2243 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  36.436927   5.080119   7.172 2.72e-12 ***\ncrim         -0.108006   0.032832  -3.290 0.001075 ** \nzn            0.046334   0.013613   3.404 0.000719 ***\nindus         0.020562   0.061433   0.335 0.737989    \nchas          2.689026   0.859598   3.128 0.001863 ** \nnox         -17.713540   3.679308  -4.814 1.97e-06 ***\nrm            3.814394   0.408480   9.338  < 2e-16 ***\ndis          -1.478612   0.190611  -7.757 5.03e-14 ***\nrad           0.305786   0.066089   4.627 4.75e-06 ***\ntax          -0.012329   0.003755  -3.283 0.001099 ** \nptratio      -0.952211   0.130294  -7.308 1.10e-12 ***\nblack         0.009321   0.002678   3.481 0.000544 ***\nlstat        -0.523852   0.047625 -10.999  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.74 on 493 degrees of freedom\nMultiple R-squared:  0.7406,    Adjusted R-squared:  0.7343 \nF-statistic: 117.3 on 12 and 493 DF,  p-value: < 2.2e-16\n\n\nAlternatively, the update() function can be used.\n\nlm.fit1 <- update(lm.fit , ~ . -age )\n\n\nInteraction terms\nit is easy to include interaction terms in a linear model using the lm() function. The syntax lstat:black tells R to include an interaction term between lstat and black. The syntax lstat*age simultaneously includes lstat, age, and the interaction term lstat:age as predictors; it is a shorthand for lstat + age + lstat:age.\n\nsummary(lm(medv ~ lstat * age , data = Boston ))\n\n\nCall:\nlm(formula = medv ~ lstat * age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.806  -4.045  -1.333   2.085  27.552 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 36.0885359  1.4698355  24.553  < 2e-16 ***\nlstat       -1.3921168  0.1674555  -8.313 8.78e-16 ***\nage         -0.0007209  0.0198792  -0.036   0.9711    \nlstat:age    0.0041560  0.0018518   2.244   0.0252 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.149 on 502 degrees of freedom\nMultiple R-squared:  0.5557,    Adjusted R-squared:  0.5531 \nF-statistic: 209.3 on 3 and 502 DF,  p-value: < 2.2e-16\n\n\n\n\nNon-linear transformation of predictors\nThe lm() function can also accommodate non-linear transformations of the predictors. For instance, given a predictor \\(X\\), we can create a predictor \\(X^2\\) using I(X^2). The function I() is needed since the ^ has a special meaning in a formula; wrapping as we do allows the standard usage in R, which is to raise X to the power 2. We now perform a regression of medv onto lstat and lstat\\(^2\\).\n\nlm.fit2 <- lm( medv ~ lstat + I(lstat^2))\nsummary(lm.fit2 )\n\n\nCall:\nlm(formula = medv ~ lstat + I(lstat^2))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.2834  -3.8313  -0.5295   2.3095  25.4148 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 42.862007   0.872084   49.15   <2e-16 ***\nlstat       -2.332821   0.123803  -18.84   <2e-16 ***\nI(lstat^2)   0.043547   0.003745   11.63   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.524 on 503 degrees of freedom\nMultiple R-squared:  0.6407,    Adjusted R-squared:  0.6393 \nF-statistic: 448.5 on 2 and 503 DF,  p-value: < 2.2e-16\n\n\n\n\nanova()\nThe near-zero p-value associated with the quadratic term suggests that it leads to an improved model. We use the anova() function to compare our models to further quantify the extent to which the quadratic ﬁt is superior to the linear ﬁt.\n\nlm.fit <- lm( medv ~ lstat)\nanova(lm.fit, lm.fit2)\n\nAnalysis of Variance Table\n\nModel 1: medv ~ lstat\nModel 2: medv ~ lstat + I(lstat^2)\n  Res.Df   RSS Df Sum of Sq     F    Pr(>F)    \n1    504 19472                                 \n2    503 15347  1    4125.1 135.2 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nHere Model 1 represents the linear submodel containing only one predictor, lstat, while Model 2 corresponds to the larger quadratic model that has two predictors, lstat and lstat2. The anova() function performs a hypothesis test comparing the two models. The null hypothesis is that the two models ﬁt the data equally well, and the alternative hypothesis is that the full model is superior. Here the F-statistic is 135 and the associated p-value is virtually zero. This provides very clear evidence that the model containing the predictors lstat and lstat\\(^2\\) is far superior to the model that only contains the predictor lstat (based on the results that the RSS, the unexplained error, is higher in Model 1). This is not surprising, since earlier we saw evidence for non-linearity in the relationship between medv and lstat. If we type\n\npar(mfrow = c(2, 2))\nplot(lm.fit2)\n\n\n\npar(mfrow = c(1, 1))\n\nthen we see that when the lstat\\(^2\\) term is included in the model, there is little discernible pattern in the residuals.\n\n\npoly()\nIn order to create a cubic ﬁt, we can include a predictor of the form I(X^3). However, this approach can start to get cumbersome for higher-order polynomials. A better approach involves using the poly() function to create the polynomial within lm(). For example, the following command produces a fifth-order polynomial fit:\n\nlm.fit5 <- lm(medv ~ poly(lstat, 5))\nsummary(lm.fit5)\n\n\nCall:\nlm(formula = medv ~ poly(lstat, 5))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-13.5433  -3.1039  -0.7052   2.0844  27.1153 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       22.5328     0.2318  97.197  < 2e-16 ***\npoly(lstat, 5)1 -152.4595     5.2148 -29.236  < 2e-16 ***\npoly(lstat, 5)2   64.2272     5.2148  12.316  < 2e-16 ***\npoly(lstat, 5)3  -27.0511     5.2148  -5.187 3.10e-07 ***\npoly(lstat, 5)4   25.4517     5.2148   4.881 1.42e-06 ***\npoly(lstat, 5)5  -19.2524     5.2148  -3.692 0.000247 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.215 on 500 degrees of freedom\nMultiple R-squared:  0.6817,    Adjusted R-squared:  0.6785 \nF-statistic: 214.2 on 5 and 500 DF,  p-value: < 2.2e-16\n\n\nThis suggests that including additional polynomial terms, up to ﬁfth order, leads to an improvement in the model ﬁt! However, further investigation of the data reveals that no polynomial terms beyond ﬁfth order have signiﬁ- cant p-values in a regression ﬁt.\n\n\nlog() transformation\nOf course, we are in no way restricted to using polynomial transformations of the predictors. Here we try a log() transformation.\n\nsummary(lm(medv~log(rm), data = Boston))\n\n\nCall:\nlm(formula = medv ~ log(rm), data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-19.487  -2.875  -0.104   2.837  39.816 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -76.488      5.028  -15.21   <2e-16 ***\nlog(rm)       54.055      2.739   19.73   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.915 on 504 degrees of freedom\nMultiple R-squared:  0.4358,    Adjusted R-squared:  0.4347 \nF-statistic: 389.3 on 1 and 504 DF,  p-value: < 2.2e-16"
  },
  {
    "objectID": "lab03-lin-reg.html#qualitative-predictors",
    "href": "lab03-lin-reg.html#qualitative-predictors",
    "title": "Lab 03 Linear regression",
    "section": "3 Qualitative predictors",
    "text": "3 Qualitative predictors\nWe will now examine the Carseats data, which is part of the {ISLR} library. We will attempt to predict Sales (child car seat sales) in 400 locations based on a number of predictors.\n\n# fix(Carseats)\nnames(Carseats)\n\n [1] \"Sales\"       \"CompPrice\"   \"Income\"      \"Advertising\" \"Population\" \n [6] \"Price\"       \"ShelveLoc\"   \"Age\"         \"Education\"   \"Urban\"      \n[11] \"US\"         \n\n\nThe Carseats data includes qualitative predictors such as Shelveloc, an indicator of the quality of the shelving location (that is, the space within a store in which the car seat is displayed at each location). The predictor Shelveloc takes on three possible values, Bad, Medium, and Good.\nGiven a qualitative variable such as Shelveloc, R generates dummy variables automatically. Below we ﬁt a multiple regression model that includes some interaction terms.\n\nlm.fit <- lm(Sales ~ . + Income:Advertising + Price:Age , data = Carseats)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = Sales ~ . + Income:Advertising + Price:Age, data = Carseats)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.9208 -0.7503  0.0177  0.6754  3.3413 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         6.5755654  1.0087470   6.519 2.22e-10 ***\nCompPrice           0.0929371  0.0041183  22.567  < 2e-16 ***\nIncome              0.0108940  0.0026044   4.183 3.57e-05 ***\nAdvertising         0.0702462  0.0226091   3.107 0.002030 ** \nPopulation          0.0001592  0.0003679   0.433 0.665330    \nPrice              -0.1008064  0.0074399 -13.549  < 2e-16 ***\nShelveLocGood       4.8486762  0.1528378  31.724  < 2e-16 ***\nShelveLocMedium     1.9532620  0.1257682  15.531  < 2e-16 ***\nAge                -0.0579466  0.0159506  -3.633 0.000318 ***\nEducation          -0.0208525  0.0196131  -1.063 0.288361    \nUrbanYes            0.1401597  0.1124019   1.247 0.213171    \nUSYes              -0.1575571  0.1489234  -1.058 0.290729    \nIncome:Advertising  0.0007510  0.0002784   2.698 0.007290 ** \nPrice:Age           0.0001068  0.0001333   0.801 0.423812    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.011 on 386 degrees of freedom\nMultiple R-squared:  0.8761,    Adjusted R-squared:  0.8719 \nF-statistic:   210 on 13 and 386 DF,  p-value: < 2.2e-16\n\n\n\ncontrasts()\nThe contrasts() function returns the coding that R uses for the dummy variables.\n\nattach(Carseats)\ncontrasts(ShelveLoc)\n\n       Good Medium\nBad       0      0\nGood      1      0\nMedium    0      1\n\n\nUse ?contrasts to learn about other contrasts, and how to set them. R has created a ShelveLocGood dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLocMedium dummy variable that equals 1 if the shelving location is medium, and 0 otherwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coeﬃcient for\nShelveLocGood in the regression output is positive indicates that a good shelving location is associated with high sales (relative to a bad location). And ShelveLocMedium has a smaller positive coeffcient, indicating that a medium shelving location leads to higher sales than a bad shelving location but lower sales than a good shelving location.\n\n\nWriting functions\nAs we have seen, R comes with many useful functions, and still more functions are available by way of R libraries. However, we will often be interested in performing an operation for which no function is available. In this setting, we may want to write our own function. For instance, below we provide a simple function that reads in the {ISLR} and {MASS} libraries, called LoadLibraries(). Before we have created the function, R returns an error if we try to call it.\n\n# try this\n# LoadLibraries()\n\nWe now create the function. The { symbol informs R that multiple commands are about to be input. Hitting Enter after typing { will cause R to print the + symbol. We can then input as many commands as we wish, hitting Enter after each one. Finally the } symbol informs R that no further commands will be entered.\n\nLoadLibraries <- function(){\n  library(ISLR)\n  library(MASS)\n  print (\"The libraries have been loaded.\")\n  }\n\nNow if we type in LoadLibraries,R will tell us what is in the function.\n\nLoadLibraries()\n\n[1] \"The libraries have been loaded.\""
  },
  {
    "objectID": "lab04-classification.html",
    "href": "lab04-classification.html",
    "title": "Lab 04 Classification",
    "section": "",
    "text": "We will begin by examining some numerical and graphical summaries of the Smarket data, which is part of the {ISLR} library. This data set consists of percentage returns for the S&P 500 stock index over 1,250 days, from the beginning of 2001 until the end of 2005. For each date, the percentage returns is recorded for each of the five previous trading days, Lag1 through Lag5. Also recorded is Volume (the number of shares traded\non the previous day, in billions), Today (the percentage return on the date in question) and Direction (whether the market was Up or Down on this date).\n\nlibrary(ISLR)\n\nWarning: package 'ISLR' was built under R version 4.1.3\n\nhead(Smarket)\n\n  Year   Lag1   Lag2   Lag3   Lag4   Lag5 Volume  Today Direction\n1 2001  0.381 -0.192 -2.624 -1.055  5.010 1.1913  0.959        Up\n2 2001  0.959  0.381 -0.192 -2.624 -1.055 1.2965  1.032        Up\n3 2001  1.032  0.959  0.381 -0.192 -2.624 1.4112 -0.623      Down\n4 2001 -0.623  1.032  0.959  0.381 -0.192 1.2760  0.614        Up\n5 2001  0.614 -0.623  1.032  0.959  0.381 1.2057  0.213        Up\n6 2001  0.213  0.614 -0.623  1.032  0.959 1.3491  1.392        Up\n\n\nThe cor() function produces a matrix that contains all of the pairwise correlations among the predictors in a data set. The ﬁrst command below gives an error message because the Direction variable is qualitative.\n\n# try this\n# cor(Smarket)\n\n\nError in cor(Smarket) : ‘x’ must be numeric\n\n\ncor(Smarket[,-9]) # 9th variable is \"Direction\"\n\n             Year         Lag1         Lag2         Lag3         Lag4\nYear   1.00000000  0.029699649  0.030596422  0.033194581  0.035688718\nLag1   0.02969965  1.000000000 -0.026294328 -0.010803402 -0.002985911\nLag2   0.03059642 -0.026294328  1.000000000 -0.025896670 -0.010853533\nLag3   0.03319458 -0.010803402 -0.025896670  1.000000000 -0.024051036\nLag4   0.03568872 -0.002985911 -0.010853533 -0.024051036  1.000000000\nLag5   0.02978799 -0.005674606 -0.003557949 -0.018808338 -0.027083641\nVolume 0.53900647  0.040909908 -0.043383215 -0.041823686 -0.048414246\nToday  0.03009523 -0.026155045 -0.010250033 -0.002447647 -0.006899527\n               Lag5      Volume        Today\nYear    0.029787995  0.53900647  0.030095229\nLag1   -0.005674606  0.04090991 -0.026155045\nLag2   -0.003557949 -0.04338321 -0.010250033\nLag3   -0.018808338 -0.04182369 -0.002447647\nLag4   -0.027083641 -0.04841425 -0.006899527\nLag5    1.000000000 -0.02200231 -0.034860083\nVolume -0.022002315  1.00000000  0.014591823\nToday  -0.034860083  0.01459182  1.000000000\n\n\nAs one might expect, the correlations between the lag variables and today’s returns are close to zero. In other words, there appears to be little correlation between today’s returns and previous days’ returns. The only substantial correlation is between Year and Volume. By plotting the data we see that Volume is increasing over time. In other words, the average number of shares traded daily increased from 2001 to 2005.\n\nattach(Smarket)\nplot(Volume,\n     pch = 16, col = \"goldenrod\", cex = 0.5) # pure vanity\n\n\n\n\n\n\n\nLogistic Regression is merely regression where the dependent variable is binary (up, down; yes, no; 0, 1; etc.).\nWe will ﬁt a logistic regression model in order to predict Direction using Lag1 through Lag5 and Volume. The glm() function ﬁts generalized linear models, a class of models that includes logistic regression, and allows us to model data that do not adhere to the Gaussian assumption. The syntax of the glm() function is similar to that of lm(), except that we must pass in the argument family=binomial in order to tell R to run a logistic regression rather than some other type of generalized linear model.\n\nglm.fit <- glm(Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume,\n               data = Smarket, \n               family = binomial )\nsummary(glm.fit)\n\n\nCall:\nglm(formula = Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + \n    Volume, family = binomial, data = Smarket)\n\nDeviance Residuals: \n   Min      1Q  Median      3Q     Max  \n-1.446  -1.203   1.065   1.145   1.326  \n\nCoefficients:\n             Estimate Std. Error z value Pr(>|z|)\n(Intercept) -0.126000   0.240736  -0.523    0.601\nLag1        -0.073074   0.050167  -1.457    0.145\nLag2        -0.042301   0.050086  -0.845    0.398\nLag3         0.011085   0.049939   0.222    0.824\nLag4         0.009359   0.049974   0.187    0.851\nLag5         0.010313   0.049511   0.208    0.835\nVolume       0.135441   0.158360   0.855    0.392\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 1731.2  on 1249  degrees of freedom\nResidual deviance: 1727.6  on 1243  degrees of freedom\nAIC: 1741.6\n\nNumber of Fisher Scoring iterations: 3\n\n\nThe smallest p-value here is associated with Lag1. The negative coefficient for this predictor suggests that if the market had a positive return yesterday, then it is less likely to go up today. However, at a value of 0.15, the p-value is still relatively large, and so there is no clear evidence of a real association between Lag1 and Direction.\nWe use the coef() function in order to access just the coefficients for this fitted model. We can also use the summary() function to access particular aspects of the fitted model, such as the p-values for the coefficients.\n\ncoef(glm.fit) # just the coefficients\n\n (Intercept)         Lag1         Lag2         Lag3         Lag4         Lag5 \n-0.126000257 -0.073073746 -0.042301344  0.011085108  0.009358938  0.010313068 \n      Volume \n 0.135440659 \n\nsummary(glm.fit)$coef # part of the summary\n\n                Estimate Std. Error    z value  Pr(>|z|)\n(Intercept) -0.126000257 0.24073574 -0.5233966 0.6006983\nLag1        -0.073073746 0.05016739 -1.4565986 0.1452272\nLag2        -0.042301344 0.05008605 -0.8445733 0.3983491\nLag3         0.011085108 0.04993854  0.2219750 0.8243333\nLag4         0.009358938 0.04997413  0.1872757 0.8514445\nLag5         0.010313068 0.04951146  0.2082966 0.8349974\nVolume       0.135440659 0.15835970  0.8552723 0.3924004\n\nsummary(glm.fit)$coef[4] # just the 4th coefficient, Lag3\n\n[1] 0.01108511\n\n\n\n\n\nThe predict() function can be used to predict the probability that the market will go up, given values of the predictors. The type=\"response\" option tells R to output probabilities of the form \\(P(Y = 1|X)\\) (the probability that Y = the value of ‘1’, given some value of X), as opposed to other information such as the logit. If no data set is supplied to the predict() function, then the probabilities are computed for the training data that was used to ﬁt the logistic regression model. Here we can print the ﬁrst ten probabilities. We know that these values correspond to the probability of the market going up, rather than down, because the contrasts() function indicates that R has created a dummy variable with a 1 for Up.\n\nglm.probs <- predict(glm.fit, type = \"response\")\nglm.probs[1:10]\n\n        1         2         3         4         5         6         7         8 \n0.5070841 0.4814679 0.4811388 0.5152224 0.5107812 0.5069565 0.4926509 0.5092292 \n        9        10 \n0.5176135 0.4888378 \n\ncontrasts(Direction)\n\n     Up\nDown  0\nUp    1\n\n\nIn order to make a prediction as to whether the market will go up or down on a particular day, we can convert these predicted probabilities into class labels, Up or Down. The following two commands create a vector of class predictions based on whether the predicted probability of a market increase is greater than or less than 0.5.\n\nglm.pred <- rep(\"Down\", 1250) # make vector\nglm.pred[glm.probs > .5] <- \"Up\" # add Up values\n\n\n\n\nThe ﬁrst command creates a vector of 1,250 Down elements. The second line transforms to Up all of the elements for which the predicted probability of a market increase exceeds 0.5. Given these predictions, the table() function can be used to produce a confusion matrix in order to determine how many observations were correctly or incorrectly classiﬁed.\n\ntable(glm.pred, Direction) # confusion matrix\n\n        Direction\nglm.pred Down  Up\n    Down  145 141\n    Up    457 507\n\n(507+145)/1250 # proportion correct predictions out of 50/50 (like flipping a coin)\n\n[1] 0.5216\n\nmean(glm.pred == Direction) # fancier programmatic calculation\n\n[1] 0.5216\n\n\nThe diagonal elements of the confusion matrix indicate correct predictions, while the off-diagonals represent incorrect predictions. Hence our model correctly predicted that the market would go up on 507 days and that it would go down on 145 days, for a total of 507 + 145 = 652 correct predictions. The mean() function can be used to compute the fraction of days for which the prediction was correct. In this case, logistic regression correctly predicted the movement of the market 52.2% of the time.\nAt ﬁrst glance, it appears that the logistic regression model is working a little better than random guessing. However, this result is misleading because we trained and tested the model on the same set of 1,250 observations. In other words, \\(100-52.2 = 47.8\\)% is the training error rate. As we have seen previously, the training error rate is often overly optimistic because it tends to underestimate the test error rate. In order to better assess the accuracy of the logistic regression model in this setting, we can ﬁt the model using part of the data, and then examine how well it predicts the held out data. This will yield a more realistic error rate, in the sense that in practice we will be interested in our model’s performance not on the data that we used to ﬁt the model, but rather on days in the future for which the market’s movements are unknown.\nTo implement this strategy, we will ﬁrst create a vector corresponding to the observations from 2001 through 2004. We will then use this vector to create a “held out” data set of observations from 2005.\n\ntrain <- (Year < 2005)\nSmarket.2005 <- Smarket[!train, ]\ndim(Smarket.2005)\n\n[1] 252   9\n\nDirection.2005 <- Direction[!train]\n\n\n\n\nThe object train is a vector of 1,250 elements, corresponding to the observations in our data set. The elements of the vector that correspond to observations that occurred before 2005 are set to TRUE, whereas those that correspond to observations in 2005 are set to FALSE. The object train is a Boolean vector, since its elements are TRUE and FALSE. Boolean vectors can be used to obtain a subset of the rows or columns of a matrix. For instance, the command Smarket[train, ] would pick out a submatrix of the stock market data set, corresponding only to the dates before 2005, since those are the ones for which the elements of train are TRUE. The ! symbol can be used to reverse all of the elements of a Boolean vector.\nThat is, !train is a vector similar to train, except that the elements that are TRUE in train get swapped to FALSE in !train, and the elements that are FALSE in train get swapped to TRUE in !train. Therefore, Smarket[!train,] yields a submatrix of the stock market data containing only the observations for which train is FALSE. That is, the observations with dates in 2005. The output above indicates that there are 252 such observations.\n\n\n\nWe now ﬁt a logistic regression model using only the subset of the observations that correspond to dates before 2005, using the subset argument. We then obtain predicted probabilities of the stock market going up for each of the days in our test set. That is, for the days in 2005.\n\nglm.fit <- glm(Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume,\n               data = Smarket, family = binomial, subset = train )\nglm.probs <- predict(glm.fit, Smarket.2005, type = \"response\")\n\nNotice that we have trained and tested our model on two completely separate data sets: training was performed using only the dates before 2005, and testing was performed using only the dates in 2005. This is the whole point.\nFinally, we compute the predictions for 2005 and compare them to the actual movements of the market over that time period.\n\nglm.pred <- rep(\"Down\", 252)\nglm.pred[glm.probs > .5] <- \"Up\"\ntable(glm.pred, Direction.2005)\n\n        Direction.2005\nglm.pred Down Up\n    Down   77 97\n    Up     34 44\n\nmean(glm.pred == Direction.2005)\n\n[1] 0.4801587\n\nmean(glm.pred != Direction.2005)\n\n[1] 0.5198413\n\n\nThe != notation means not equal to, and so the last command computes the test set error rate. The results are rather disappointing: the test error rate is 52%, which is worse than random guessing! Of course this result is not all that surprising, given that one would not generally expect to be able to use previous days’ returns to predict future market performance. (After all, if it were easy to do so economics would not be a field of study)"
  },
  {
    "objectID": "lab04-classification.html#exercises",
    "href": "lab04-classification.html#exercises",
    "title": "Lab 04 Classification",
    "section": "6 Exercises",
    "text": "6 Exercises\n\nExercise 1\nThe next few questions should be answered using the Weekly data set, which is part of the {ISLR2} package. (read about it in help())\n\n1.1\nProduce some numerical and graphical summaries of the Weekly data. Do there appear to be any patterns?\n\n\n1.2\nUse the full data set to perform a logistic regression with Direction as the response and the five lag variables plus Volume as predictors. Use the summary function to print the results. Do any of the predictors appear to be statistically significant? If so, which ones?\n\n\n1.3\nCompute the confusion matrix and overall fraction of correct predictions. Explain what the confusion matrix is telling you about the types of mistakes made by logistic regression.\n\n\n1.4\nNow fit the logistic regression model using a training data period from 1990 to 2008, with Lag2 as the only predictor. Compute the confusion matrix and the overall fraction of correct predictions for the held out data (that is, the data from 2009 and 2010).\n\n\n1.5\nRepeat 1.4 using LDA.\n\n\n1.6\nRepeat 1.4 using QDA.\n\n\n1.7\nRepeat 1.4 using KNN with K = 1.\n\n\n1.8\nRepeat 1.4 using naive Bayes.\n\n\n1.9\nWhich of these methods appears to provide the best results on this data?\n\n\n1.10\nExperiment with diﬀerent combinations of predictors, including possible transformations and interactions, for each of the methods. Report the variables, method, and associated confusion matrix that appears to provide the best results on the held out data. Note that you should also experiment with values for K in the KNN classifier."
  },
  {
    "objectID": "lab04-classification.html#resources",
    "href": "lab04-classification.html#resources",
    "title": "Lab 04 Classification",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "lab04-classification.html#harper-adams-data-science",
    "href": "lab04-classification.html#harper-adams-data-science",
    "title": "Lab 04 Classification",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab04-classification.html#fine-tuning-models",
    "href": "lab04-classification.html#fine-tuning-models",
    "title": "Lab 04 Classification",
    "section": "2 Fine tuning models",
    "text": "2 Fine tuning models\nWe recall that the logistic regression model had very underwhelming p-values associated with all of the predictors, and that the smallest p-value, though not very small, corresponded to Lag1. Perhaps by removing the variables that appear not to be helpful in predicting Direction, we can obtain a more eﬀective model. After all, using predictors that have no relationship with the response tends to cause a deterioration in the test error rate (since such predictors cause an increase in variance without a corresponding decrease in bias), and so removing such predictors may in turn yield an improvement. Below we will refit the logistic regression using just Lag1 and Lag2, which seemed to have the highest predictive power in the original logistic regression model.\n\nglm.fit <- glm (Direction ~ Lag1 + Lag2, data = Smarket, \n                  family = binomial, subset = train)\nglm.probs <- predict(glm.fit, Smarket.2005, type = \"response\")\nglm.pred <- rep (\"Down\" ,252)\nglm.pred[glm.probs > .5] = \"Up\"\ntable(glm.pred, Direction.2005)\n\n        Direction.2005\nglm.pred Down  Up\n    Down   35  35\n    Up     76 106\n\nmean(glm.pred == Direction.2005)\n\n[1] 0.5595238\n\n106/(106+76) \n\n[1] 0.5824176\n\n\nNow the results appear to be a little better: 56% of the daily movements have been correctly predicted. It is worth noting that in this case, a much simpler strategy of predicting that the market will increase every day will also be correct 56% of the time! Hence, in terms of overall error rate, the logistic regression method is no better than the naïve approach. However, the confusion matrix shows that on days when logistic regression predicts an increase in the market, it has a 58% accuracy rate. This suggests a possible trading strategy of buying on days when the model predicts an increasing market, and avoiding trades on days when a decrease is predicted. Of course one would need to investigate more carefully whether this small improvement was real or just due to random chance.\n\nMore predict()\nSuppose that we want to predict the returns associated with particular values of Lag1 and Lag2. In particular, we want to predict Direction on a day when Lag1 and Lag2 equal 1.2 and 1.1, respectively, and on a day when they equal 1.5 and −0.8. We do this using the predict() function.\n\npredict(glm.fit, \n        newdata = data.frame(Lag1 = c(1.2, 1.5),\n                                      Lag2 =c(1.1, -0.8)), \n        type = \"response\")\n\n        1         2 \n0.4791462 0.4960939"
  },
  {
    "objectID": "lab04-classification.html#lda",
    "href": "lab04-classification.html#lda",
    "title": "Lab 04 Classification",
    "section": "3 LDA",
    "text": "3 LDA\n\nlda()\nWe use Linear Discriminant Analysis (LDA) to explore differences between data with two or more classes.\nNow we will perform LDA on the Smarket data. In R, we ﬁt a LDA model using the lda() function, which is part of the MASS library. Notice that the syntax for the lda() function is identical to that of lm(), and to that of glm() except for the absence of the family option. We ﬁt the model using only the observations before 2005.\n\nlibrary(MASS)\nlda.fit <- lda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\nlda.fit\n\nCall:\nlda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\n\nPrior probabilities of groups:\n    Down       Up \n0.491984 0.508016 \n\nGroup means:\n            Lag1        Lag2\nDown  0.04279022  0.03389409\nUp   -0.03954635 -0.03132544\n\nCoefficients of linear discriminants:\n            LD1\nLag1 -0.6420190\nLag2 -0.5135293\n\nplot(lda.fit)\n\n\n\n\nThe LDA output indicates that \\(\\hat\\pi_1 = 0.492\\) and \\(\\hat\\pi_2 = 0.508\\); in other words, 49.2% of the training observations correspond to days during which the market went down. It also provides the group means; these are the average of each predictor within each class, and are used by LDA as estimates of \\(μ_k\\). These suggest that there is a tendency for the previous 2 days’ returns to be negative on days when the market increases, and a tendency for the previous days’ returns to be positive on days when the market declines. The coefficients of linear discriminants output provides the linear combination of Lag1 and Lag2 that are used to form the LDA decision rule.\nIn other words, these are the multipliers of the elements of X = x in (4.19). If −0.642 × Lag1− 0.514 × Lag2 is large, then the LDA classiﬁer will predict a market increase, and if it is small, then the LDA classifier will predict a market decline. The plot() function produces plots of the linear discriminants, obtained by computing 0.642 X Lag1 - 0.514 Lag2 for each of the training observations.\nThe predict() function returns a list with three elements. The ﬁrst element, class, contains LDA’s predictions about the movement of the market. The second element, posterior, is a matrix whose kth column contains the posterior probability that the corresponding observation belongs to the kth class. Finally, x contains the linear discriminants, described earlier.\n\nlda.pred = predict(lda.fit, Smarket.2005)\nnames(lda.pred)\n\n[1] \"class\"     \"posterior\" \"x\"        \n\n\nthe LDA and logistic regression predictions are almost identical for this example.\n\nlda.class = lda.pred$class\ntable(lda.class, Direction.2005)\n\n         Direction.2005\nlda.class Down  Up\n     Down   35  35\n     Up     76 106\n\nmean(lda.class == Direction.2005)\n\n[1] 0.5595238\n\n\nApplying a 50% threshold to the posterior probabilities allows us to recreate the predictions contained in lda.pred$class.\n\nsum( lda.pred$posterior[, 1] >= .5)\n\n[1] 70\n\nsum( lda.pred$posterior[, 1] < .5)\n\n[1] 182\n\n\nNotice that the posterior probability output by the model corresponds to the probability that the market will decrease:\n\nlda.pred$posterior[1:20, 1]\n\n      999      1000      1001      1002      1003      1004      1005      1006 \n0.4901792 0.4792185 0.4668185 0.4740011 0.4927877 0.4938562 0.4951016 0.4872861 \n     1007      1008      1009      1010      1011      1012      1013      1014 \n0.4907013 0.4844026 0.4906963 0.5119988 0.4895152 0.4706761 0.4744593 0.4799583 \n     1015      1016      1017      1018 \n0.4935775 0.5030894 0.4978806 0.4886331 \n\nlda.class[1:20] \n\n [1] Up   Up   Up   Up   Up   Up   Up   Up   Up   Up   Up   Down Up   Up   Up  \n[16] Up   Up   Down Up   Up  \nLevels: Down Up\n\n\nIf we wanted to use a posterior probability threshold other than 50% in order to make predictions, then we could easily do so. For instance, suppose that we wish to predict a market decrease only if we are very certain that the market will indeed decrease on that day. Say, if the posterior probability is at least 90%.\n\nsum(lda.pred$posterior[ , 1] > .9)\n\n[1] 0\n\n\nNo days in 2005 meet that threshold! In fact, the greatest posterior probability of decrease in all of 2005 was 52.02%."
  },
  {
    "objectID": "lab04-classification.html#qda",
    "href": "lab04-classification.html#qda",
    "title": "Lab 04 Classification",
    "section": "4 QDA",
    "text": "4 QDA\n\nqda() Quadratic Discriminant Analysis\nWe will now ﬁt a QDA model to the Smarket data. QDA is implemented in R using the qda() function, which is also part of the {MASS} library. The syntax is identical to that of lda().\n\nqda.fit <- qda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\nqda.fit\n\nCall:\nqda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\n\nPrior probabilities of groups:\n    Down       Up \n0.491984 0.508016 \n\nGroup means:\n            Lag1        Lag2\nDown  0.04279022  0.03389409\nUp   -0.03954635 -0.03132544\n\n\nThe output contains the group means. But it does not contain the coefﬁcients of the linear discriminants, because the QDA classiﬁer involves a quadratic, rather than a linear, function of the predictors. The predict() function works in exactly the same fashion as for LDA.\n\nqda.class <- predict(qda.fit, Smarket.2005)$class\ntable(qda.class, Direction.2005)\n\n         Direction.2005\nqda.class Down  Up\n     Down   30  20\n     Up     81 121\n\nmean(qda.class == Direction.2005)\n\n[1] 0.5992063\n\n\nInterestingly, the QDA predictions are accurate almost 60% of the time, even though the 2005 data was not used to ﬁt the model. This level of accuracy is quite impressive for stock market data, which is known to be quite hard to model accurately. This suggests that the quadratic form assumed by QDA may capture the true relationship more accurately than the linear forms assumed by LDA and logistic regression. However, it is recommended to evaluate any method’s performance on a larger test set before betting that this approach will consistently beat the market!"
  },
  {
    "objectID": "lab04-classification.html#k-nearest-neighbors",
    "href": "lab04-classification.html#k-nearest-neighbors",
    "title": "Lab 04 Classification",
    "section": "5 K-Nearest Neighbors",
    "text": "5 K-Nearest Neighbors\n\nknn()\nWe will now perform KNN using the knn() function, which is part of the {class} library. This function works rather differently from the other model-fitting functions that we have encountered thus far. Rather than a two-step approach in which we ﬁrst ﬁt the model and then we use the model to make predictions, knn() forms predictions using a single command. The function requires four inputs.\n\nA matrix containing the predictors associated with the training data, labeled train.X below.\nA matrix containing the predictors associated with the data for which we wish to make predictions, labeled test.X below.\nA vector containing the class labels for the training observations, labeled train.Direction below.\nA value for K, the number of nearest neighbors to be used by the classifier.\n\nWe will use the cbind() function, short for column bind, to bind the Lag1 and Lag2 variables together into two matrices, one for the training set and the other for the test set.\n\nlibrary( class)\ntrain.X <- cbind(Lag1, Lag2)[train, ]\ntest.X <- cbind(Lag1, Lag2)[!train, ]\ntrain.Direction <- Direction[train]\n\nNow the knn() function can be used to predict the market’s movement for the dates in 2005. We set a random seed before we apply knn() because if several observations are tied as nearest neighbors, then R will randomly break the tie. Therefore, a seed must be set in order to ensure reproducibility of results.\n\nset.seed(1)\nlibrary(class)\nknn.pred <- knn(train.X, test.X, train.Direction, k = 1)\ntable(knn.pred, Direction.2005)\n\n        Direction.2005\nknn.pred Down Up\n    Down   43 58\n    Up     68 83\n\n(83+43) /252\n\n[1] 0.5\n\n\nThe results using K = 1 are not very good, since only 50% of the observa- tions are correctly predicted. Of course, it may be that K = 1 results in an overly ﬂexible ﬁt to the data. Let’s repeat the analysis using a different K, K = 3.\n\nknn.pred <- knn(train.X, test.X, train.Direction, k = 3)\ntable(knn.pred, Direction.2005)\n\n        Direction.2005\nknn.pred Down Up\n    Down   48 54\n    Up     63 87\n\nmean (knn.pred == Direction.2005)\n\n[1] 0.5357143\n\n\nThe results have improved slightly. But increasing K further turns out to provide no further improvements. It appears that for this data, QDA provides the best results of the methods that we have examined so far.\n\n\nCaravan insurance data\nFinally, we will apply the KNN approach to the Caravan data set, which is part of the {ISLR} library. This data set includes 85 predictors that measure demographic characteristics for 5,822 individuals. The response variable is Purchase, which indicates whether or not a given individual purchases a caravan insurance policy. In this data set, only 6% of people purchased caravan insurance.\n\ndim(Caravan)\n\n[1] 5822   86\n\nattach(Caravan)\nsummary(Purchase) \n\n  No  Yes \n5474  348 \n\n348/5822 # % purchasing insurance\n\n[1] 0.05977327\n\n\nBecause the KNN classiﬁer predicts the class of a given test observation by identifying the observations that are nearest to it, the scale of the variables matters. Any variables that are on a large scale will have a much larger eﬀect on the distance between the observations, and hence on the KNN classiﬁer, than variables that are on a small scale. For instance, imagine a data set that contains two variables, salary and age (measured in dollars and years, respectively). As far as KNN is concerned, a difference of $1,000 in salary is enormous compared to a difference of 50 years in age. Consequently, salary will drive the KNN classification results, and age will have almost no effect. This is contrary to our intuition that a salary difference of $1,000 is quite small compared to an age difference of 50 years. Furthermore, the importance of scale to the KNN classiﬁer leads to another issue: if we measured salary in British Pounds, or if we measured age in minutes, then we’d get quite diﬀerent classification results from what we get if these two variables are measured in dollars and years.\n\n\nStandardizing data\nA good way to handle this problem is to standardize the data so that all variables are given a mean of zero and a standard deviation of one. Then all variables will be on a comparable scale. The scale() function does just this. In standardizing the data, we exclude column 86, because that is the qualitative Purchase variable.\n\nstandardized.X <- scale(Caravan [,-86])\nvar(Caravan[,1])\n\n[1] 165.0378\n\nvar(Caravan[,2])\n\n[1] 0.1647078\n\nvar(standardized.X[,1])\n\n[1] 1\n\nvar(standardized.X[,2])\n\n[1] 1\n\n\nNow every column of standardized.X has a standard deviation of one and a mean of zero.\nWe now split the observations into a test set, containing the ﬁrst 1,000 observations, and a training set, containing the remaining observations. We ﬁt a KNN model on the training data using K = 1, and evaluate its performance on the test data.\n\ntest <- 1:1000\ntrain.X <- standardized.X[-test, ]\ntest.X <- standardized.X[test, ]\ntrain.Y <- Purchase[-test]\ntest.Y <- Purchase[test]\n\nset.seed(1)\nknn.pred <- knn(train.X, test.X, train.Y, k = 1)\nmean(test.Y != knn.pred )\n\n[1] 0.118\n\nmean(test.Y != \"No\")\n\n[1] 0.059\n\n\nThe vector test is numeric, with values from 1 through 1,000. Typing standardized.X[test, ] yields the submatrix of the data containing the observations whose indices range from 1 to 1,000, whereas typing standardized.X[-test, ] yields the submatrix containing the observations whose indices do not range from 1 to 1,000. The KNN error rate on the 1,000 test observations is just under 12%. At ﬁrst glance, this may appear to be fairly good. However, since only 6% of customers purchased insurance, we could get the error rate down to 6% by always predicting No regardless of the values of the predictors!\nSuppose that there is some non-trivial cost to trying to sell insurance to a given individual. For instance, perhaps a salesperson must visit each potential customer. If the company tries to sell insurance to a random selection of customers, then the success rate will be only 6%, which may be far too low given the costs involved. Instead, the company would like to try to sell insurance only to customers who are likely to buy it. So the overall error rate is not of interest. Instead, the fraction of individuals that are correctly predicted to buy insurance is of interest.\nIt turns out that KNN with K = 1 does far better than random guessing among the customers that are predicted to buy insurance. Among 77 such customers, 9, or 11.7%, actually do purchase insurance. This is double the rate that one would obtain from random guessing.\n\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  873  50\n     Yes  68   9\n\n9/(68+9)\n\n[1] 0.1168831\n\n\n\n\nExploring KNN model tuning\nUsing K = 3 (implying there are 3 groupings of customers), the success rate increases to 19%, and with K = 5 (5 groups) the rate is 26.7%. This is over four times the rate that results from random guessing. It appears that KNN is ﬁnding some real patterns in a difficult data set!\n\nknn.pred <- knn(train.X, test.X, train.Y, k = 3)\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  920  54\n     Yes  21   5\n\n5/26\n\n[1] 0.1923077\n\nknn.pred <- knn(train.X, test.X, train.Y, k = 5)\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  930  55\n     Yes  11   4\n\n4/15\n\n[1] 0.2666667\n\n\n\n\nCompare to logistic regression\nAs a comparison, we can also ﬁt a logistic regression model to the data. If we use 0.5 as the predicted probability cut-off for the classifier, then we have a problem: only seven of the test observations are predicted to purchase insurance. Even worse, we are wrong about all of these! However, we are not required to use a cut-off of 0.5. If we instead predict a purchase any time the predicted probability of purchase exceeds 0.25, we get much better results: we predict that 33 people will purchase insurance, and we are correct for about 33% of these people. This is over ﬁve times better than random guessing!\n\nglm.fit <- glm(Purchase ~ ., data = Caravan, family = binomial,\n               subset = -test)\n\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n\nglm.probs <- predict(glm.fit, Caravan[test, ], type = \"response\")\nglm.pred <- rep(\"No\" , 1000)\nglm.pred [glm.probs > .5]= \"Yes\"\ntable(glm.pred, test.Y)\n\n        test.Y\nglm.pred  No Yes\n     No  934  59\n     Yes   7   0\n\nglm.pred <- rep(\"No\", 1000)\nglm.pred[glm.probs > .25] <- \"Yes\"\ntable(glm.pred, test.Y)\n\n        test.Y\nglm.pred  No Yes\n     No  919  48\n     Yes  22  11\n\n11/(22+11 )\n\n[1] 0.3333333"
  },
  {
    "objectID": "lab05-resampling.html#exercises",
    "href": "lab05-resampling.html#exercises",
    "title": "Lab 05 Resampling",
    "section": "4 Exercises",
    "text": "4 Exercises\n\nExercise 1\nWe have used logistic regression to predict the probability of default using income and balance on the Default data set. We will now estimate the test error of this logistic regression model using the validation set approach. Do not forget to set a random seed before beginning your analysis.\n\n1.1\nFit a logistic regression model that uses income and balance to predict default.\n\n\n1.2\nUsing the validation set approach, estimate the test error of this model. In order to do this, you must perform the following steps:\n\nSplit the sample set into a training set and a validation set.\nFit a multiple logistic regression model using only the training observations.\nObtain a prediction of default status for each individual in the validation set by computing the posterior probability of default for that individual, and classifying the individual to the default category if the posterior probability is greater than 0.5.\nCompute the validation set error, which is the fraction of the observations in the validation set that are misclassified.\n\n\n\n1.3\nRepeat the process in 1.2 three times, using three diﬀerent splits of the observations into a training set and a validation set. Comment on the results obtained.\n\n\n1.4\nNow consider a logistic regression model that predicts the probability of default using income, balance, and a dummy variable for student. Estimate the test error for this model using the validation set approach. Comment on whether or not including a dummy variable for student leads to a reduction in the test error rate."
  },
  {
    "objectID": "lab05-resampling.html#resources",
    "href": "lab05-resampling.html#resources",
    "title": "Lab 05 Resampling",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "lab05-resampling.html#harper-adams-data-science",
    "href": "lab05-resampling.html#harper-adams-data-science",
    "title": "Lab 05 Resampling",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab05-resampling.html",
    "href": "lab05-resampling.html",
    "title": "Lab 05 Resampling",
    "section": "",
    "text": "In this lab, we explore the resampling techniques covered in this chapter. Some of the commands in this lab may take a while to run on your computer.\n\n\nWe explore the use of the validation set approach in order to estimate the test error rates that result from ﬁtting various linear models on the Auto data set.\nBefore we begin, we use the set.seed() function in order to set a seed for R’s random number generator, so that the reader of this book will obtain precisely the same results as those shown below. It is generally a good idea to set a random seed when performing an analysis such as cross-validation that contains an element of randomness, so that the results obtained can be reproduced precisely at a later time.\n\n\n\nWe begin by using the sample() function to split the set of observations into two halves, by selecting a random subset of 196 observations out of the original 392 observations. We refer to these observations as the training set.\n\nlibrary(ISLR)\n\nWarning: package 'ISLR' was built under R version 4.1.3\n\nset.seed(1)\ntrain <- sample(392, 196)\n\n(Here we use a shortcut in the sample command; see ?sample for details.) We then use the subset option in lm() to ﬁt a linear regression using only the observations corresponding to the training set.\n\nlm.fit <- lm(mpg ~ horsepower, data = Auto, subset = train)\n\nWe now use the predict() function to estimate the response for all 392 observations, and we use the mean() function to calculate the MSE of the 196 observations in the validation set. Note that the -train index below selects only the observations that are not in the training set.\n\nattach(Auto)\nmean((mpg - predict(lm.fit, Auto))[-train]^2)\n\n[1] 23.26601\n\n\nTherefore, the estimated test MSE for the linear regression ﬁt is 26.14.\n\n\n\nWe can use the poly() function to estimate the test error for polynomial and cubic regressions.\n\n# poly 2nd degree\nlm.fit2 <- lm(mpg ~ poly(horsepower, 2), \n              data = Auto, subset = train)\n\nmean((mpg - predict(lm.fit2, Auto))[-train ]^2)\n\n[1] 18.71646\n\n# poly 3rd degree\nlm.fit3 <- lm(mpg ~ poly(horsepower, 3), \n              data = Auto, subset = train )\nmean((mpg - predict(lm.fit3, Auto ))[-train ]^2)\n\n[1] 18.79401\n\n\nThese error rates are similar to each other, respectively. But, if we choose a different training set instead, then we will obtain somewhat diﬀerent errors on the validation set.\n\nset.seed(2)\ntrain <- sample(392, 196)\n\nlm.fit <- lm(mpg ~ horsepower, subset = train)\nmean((mpg - predict(lm.fit, Auto ))[ -train]^2)\n\n[1] 25.72651\n\nlm.fit2 <- lm(mpg ~ poly(horsepower, 2), data = Auto, subset = train)\nmean(( mpg - predict( lm.fit2 , Auto ))[ -train]^2)\n\n[1] 20.43036\n\nlm.fit3 <- lm (mpg ~ poly(horsepower, 3), data = Auto , subset = train)\nmean(( mpg - predict (lm.fit3, Auto ))[ -train]^2)\n\n[1] 20.38533\n\n\nAlthough the values are slightly different, these results are consistent with our previous ﬁndings: a model that predicts mpg using a quadratic function of horsepower performs better than a model that involves only a linear function of horsepower, and there is little evidence in favor of a model that uses a cubic function of horsepower."
  },
  {
    "objectID": "lab05-resampling.html#cross-validation",
    "href": "lab05-resampling.html#cross-validation",
    "title": "Lab 05 Resampling",
    "section": "2 Cross validation",
    "text": "2 Cross validation\n\nLeave-one-out CV\nT leave-one-out Cross-validation (LOOCV) estimate can be automatically computed for any generalized linear model using the glm() and cv.glm() functions. We can use the glm() function to perform logistic regression by passing in the family=\"binomial\" argument. But if we use glm() to ﬁt a model without passing in the family argument, then it performs linear regression, just like the lm() function. So for instance,\n\n\ncv.glm()\n\n# glm() approach\nglm.fit <- glm(mpg ~ horsepower, data = Auto)\ncoef(glm.fit )\n\n(Intercept)  horsepower \n 39.9358610  -0.1578447 \n\n# lm() approach\nlm.fit <- lm(mpg ~ horsepower, data = Auto)\ncoef(lm.fit)\n\n(Intercept)  horsepower \n 39.9358610  -0.1578447 \n\n\nyield identical linear regression models. In this lab, we will perform linear regression using the glm() function rather than the lm() function because the latter can be used together with cv.glm(). The cv.glm() function is part of the {boot} library.\n\nlibrary(boot)\nglm.fit <- glm(mpg ~ horsepower, data = Auto )\ncv.err <- cv.glm(Auto, glm.fit)\ncv.err$delta\n\n[1] 24.23151 24.23114\n\n\nThe cv.glm() function produces a list with several components. The two numbers in the delta vector contain the cross-validation results. In this case the numbers are identical (up to two decimal places) and correspond to the LOOCV statistic (Ch 5 James et al. 2021). Below, we discuss a situation in which the two numbers differ. Our cross-validation estimate for the test error is approximately 24.23.\n\n\nfor()\nWe can repeat this procedure for increasingly complex polynomial fits. To automate the process, we use the for() function to initiate a for loop which iteratively ﬁts polynomial regressions for polynomials of order i = 1 to i = 5, computes the associated cross-validation error, and stores it in the ith element of the vector cv.error. We begin by initializing the vector. This command will likely take some time to run.\n\nlibrary(tictoc) # time your computer\ncv.error <- rep(0 ,5)\ntic()\nfor (i in 1:5){\n  glm.fit <- glm(mpg ~ poly(horsepower, i), data = Auto)\n  cv.error[i] <- cv.glm(Auto, glm.fit)$delta[1]\n}\ntoc() # Ed's PC\n\n4.39 sec elapsed\n\ncv.error\n\n[1] 24.23151 19.24821 19.33498 19.42443 19.03321\n\nplot(cv.error, type='b')\n\n\n\n\nWe see a sharp drop in the estimated test MSE between the linear and quadratic ﬁts, but then no clear improvement from using higher-order polynomials.\n\n\nK-fold CV\nThe cv.glm() function can also be used to implement k-fold CV. Below we use k = 10, a common choice for k, on the Auto data set. We once again set a random seed and initialize a vector in which we will store the CV errors corresponding to the polynomial ﬁts of orders one to ten.\n\nset.seed(17)\ncv.error.10 <- rep (0 ,10)\nfor(i in  1:10) {\n  glm.fit <- glm(mpg ~ poly(horsepower, i), data = Auto )\n  cv.error.10[i] = cv.glm(Auto, glm.fit, K = 10)$delta[1]\n}\ncv.error.10\n\n [1] 24.27207 19.26909 19.34805 19.29496 19.03198 18.89781 19.12061 19.14666\n [9] 18.87013 20.95520\n\nplot(cv.error.10, type='b')\n\n\n\n\nYou may notice that the computation time is much shorter than that of LOOCV. (In principle, the computation time for LOOCV for a least squares linear model should be faster than for k-fold CV, due to a mathematical shortcut for LOOCV (see Ch 5 James et al. 2021); however, unfortunately the cv.glm() function does not make use of this efficiency. We still see little evidence that using cubic or higher-order polynomial terms leads to lower test error than simply using a quadratic fit.\nThe two numbers associated with delta are essentially the same when LOOCV is performed. When we instead perform k-fold CV, then the two numbers associated with delta differ slightly. The first is the standard k-fold CV estimate and the second is a bias-corrected version. On this data set, we see the two estimates are very similar to each other."
  },
  {
    "objectID": "lab05-resampling.html#bootstrap",
    "href": "lab05-resampling.html#bootstrap",
    "title": "Lab 05 Resampling",
    "section": "3 Bootstrap",
    "text": "3 Bootstrap\nWe will illustrate the use of the bootstrap in a simple example, as well as on an example involving estimating the accuracy of the linear regression model on the Auto data set.\n\nboot()\nOne of the great advantages of the bootstrap approach is that it can be applied in almost all situations. No complicated mathematical calculations are required. Performing a bootstrap analysis in R entails only two steps. First, we must create a function that computes the statistic of interest. Second, we use the boot() function, which is part of the {boot} library, to perform the bootstrap by repeatedly sampling observations from the data set with replacement.\nThe Portfolio data set in the {ISLR} package is described in Section 5.2. To illustrate the use of the bootstrap on this data, we must ﬁrst create a function, alpha.fn(), which takes as input the (X, Y) data as well as a vector indicating which observations should be used to estimate α. The function then outputs the estimate for α based on the selected observations.\n\n# make a fun function\nalpha.fn <- function(data, index){\n  X <- data$X[index]\n  Y <- data$Y[index]\n  return((var(Y) - cov (X, Y))/(var(X)+ var(Y)-2 * cov(X,Y)))\n}\n\nThis function returns, or outputs, an estimate for α based on the observations indexed by the argument index. For instance, the following command tells R to estimate α using all 100 observations.\n\nalpha.fn(Portfolio, 1:100)\n\n[1] 0.5758321\n\n\nThe next command uses the sample() function to randomly select 100 observations from the range 1 to 100, with replacement. This is equivalent to constructing a new bootstrap data set and recomputing \\(\\hat\\alpha\\) based on the new data set.\n\nset.seed(1)\nalpha.fn(Portfolio, sample(100, 100, replace = T))\n\n[1] 0.7368375\n\n\nWe can implement a bootstrap analysis by performing this command many times, recording all of the corresponding estimates for α, and computing the resulting standard deviation. However, the boot() function automates this approach. Below we produce R = 1,000 bootstrap estimates for α.\n\nset.seed(1)\nboot(Portfolio, alpha.fn, R = 1000)\n\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = Portfolio, statistic = alpha.fn, R = 1000)\n\n\nBootstrap Statistics :\n     original       bias    std. error\nt1* 0.5758321 -0.001596422  0.09376093\n\n\nThe ﬁnal output shows that using the original data, \\(\\hat\\alpha= 0.58\\), and that the bootstrap estimate for \\(SE\\hat\\alpha = 0.09\\).\n\n\nRegression accuracy\nThe bootstrap approach can be used to assess the variability of the coef- ﬁcient estimates and predictions from a statistical learning method. Here we use the bootstrap approach in order to assess the variability of the estimates for \\(\\beta_0\\) and \\(\\beta_1\\), the intercept and slope terms for the linear regression model that uses horsepower to predict mpg in the Auto data set. We will compare the estimates obtained using the bootstrap to those obtained using the formulas for \\(SE(\\hat\\beta_0)\\) and \\(SE(\\hat\\beta_1)\\).\nWe ﬁrst create a simple function, boot.fn(), which takes in the Auto data set as well as a set of indices for the observations, and returns the intercept and slope estimates for the linear regression model. We then apply this function to the full set of 392 observations in order to compute the estimates of \\(\\beta_0\\) and \\(\\beta_1\\) on the entire data set using the usual linear regression coefficient estimate formulas. Note that we do not need the { and } at the beginning and end of the function because it is only one line long.\n\nplot(mpg ~ horsepower, data = Auto)\nabline(lm(mpg ~ horsepower, data = Auto))\n\n\n\n# function!\nboot.fn <- function(data, index)\n  return(coef(lm(mpg ~ horsepower, data = data, subset = index)))\nboot.fn(Auto, 1:392)\n\n(Intercept)  horsepower \n 39.9358610  -0.1578447 \n\n\nThe boot.fn() function can also be used in order to create bootstrap estimates for the intercept and slope terms by randomly sampling from among the observations with replacement. Here are two examples:\n\n# first with a seed\nset.seed(1)\nboot.fn(Auto, sample(392, 392, replace = T)) \n\n(Intercept)  horsepower \n 40.3404517  -0.1634868 \n\n# no seed\nboot.fn(Auto, sample(392, 392, replace = T)) \n\n(Intercept)  horsepower \n 40.1186906  -0.1577063 \n\n\n\n\nBootstrap\n\nboot(Auto, boot.fn, 1000)\n\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = Auto, statistic = boot.fn, R = 1000)\n\n\nBootstrap Statistics :\n      original        bias    std. error\nt1* 39.9358610  0.0544513229 0.841289790\nt2* -0.1578447 -0.0006170901 0.007343073\n\n\nand\nThis indicates that the bootstrap estimate for \\(SE(\\hat\\beta_0)\\) is 0.84, and that the bootstrap estimate for \\(SE(\\hat\\beta_1)\\) is 0.0074. Standard formulas can be used to compute the standard errors for the regression coefficients in a linear model. These can be obtained using the summary() function.\n\nsummary(lm(mpg ~ horsepower, data = Auto))$coef\n\n              Estimate  Std. Error   t value      Pr(>|t|)\n(Intercept) 39.9358610 0.717498656  55.65984 1.220362e-187\nhorsepower  -0.1578447 0.006445501 -24.48914  7.031989e-81\n\n\nThe standard error estimates for \\(SE(\\hat\\beta_0)\\) and \\(SE(\\hat\\beta_1)\\) somewhat diﬀerent from the estimates obtained using the bootstrap. Does this indicate a problem with the bootstrap? In fact, it suggests the opposite. Consider that estimation of these parameters rely on certain assumptions. For example, they depend on the unknown parameter \\(\\sigma^2\\), the noise variance. We then estimate \\(\\sigma^2\\) using the RSS. Now although the formula for the standard errors do not rely on the linear model being correct, the estimate for \\(\\sigma^2\\) does. Also, there is a non-linear relationship in the data, and so the residuals from a linear ﬁt will be inflated, and so will \\(\\sigma^2\\). Secondly, standard linear regression assume (somewhat unrealistically) that the \\(x_i\\) values are ﬁxed, and all the variability comes from the variation in the errors \\(\\epsilon_i\\). The bootstrap approach does not rely on any of these assumptions, and so it is likely giving a more accurate estimate of the standard errors of \\(SE(\\hat\\beta_0)\\) and \\(SE(\\hat\\beta_1)\\) than is the summary() function.\nBelow we compute the bootstrap standard error estimates and the standard linear regression estimates that result from ﬁtting the quadratic model to the data. Since this model provides a good ﬁt to the data, there is now a better correspondence between the bootstrap estimates and the standard estimates of \\(SE(\\hat\\beta_0)\\), \\(SE(\\hat\\beta_1)\\) and \\(SE(\\hat\\beta_2)\\).\n\nboot.fn <- function(data, index){\n  coefficients(lm(mpg ~ horsepower + I(horsepower^2), \n                  data=data, \n                  subset = index))\n}\n\nset.seed(1)\nboot(Auto, boot.fn, 1000)\n\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = Auto, statistic = boot.fn, R = 1000)\n\n\nBootstrap Statistics :\n        original        bias     std. error\nt1* 56.900099702  3.511640e-02 2.0300222526\nt2* -0.466189630 -7.080834e-04 0.0324241984\nt3*  0.001230536  2.840324e-06 0.0001172164\n\nsummary(lm(mpg ~ horsepower + I(horsepower^2), data = Auto))$coef\n\n                    Estimate   Std. Error   t value      Pr(>|t|)\n(Intercept)     56.900099702 1.8004268063  31.60367 1.740911e-109\nhorsepower      -0.466189630 0.0311246171 -14.97816  2.289429e-40\nI(horsepower^2)  0.001230536 0.0001220759  10.08009  2.196340e-21"
  },
  {
    "objectID": "lab02-R-practice.html#exercises",
    "href": "lab02-R-practice.html#exercises",
    "title": "Lab 02 R practice",
    "section": "5 Exercises",
    "text": "5 Exercises\n\nExercise 1\nThis exercise relates to the College data set csv file. It contains a number of variables for 777 different universities in the US. The variables are\n\nPrivate : Public/private indicator\nApps : Number of applications received\nAccept : Number of applicants accepted\nEnroll : Number of new students enrolled\nTop10perc : New students from top 10% of high school class\nTop25perc : New students from top 25% of high school class\nF.Undergrad : Number of full-time undergraduates\nP.Undergrad : Number of part-time undergraduates\nOutstate : Out-of-state tuition\nRoom.Board : Room and board costs\nBooks : Estimated book costs\nPersonal : Estimated personal spending\nPhD : Percent of faculty with Ph.D.’s\nTerminal : Percent of faculty with terminal degree\nS.F.Ratio : Student/faculty ratio\nperc.alumni : Percent of alumni who donate\nExpend : Instructional expenditure per student\nGrad.Rate : Graduation rate\n\nBefore reading the data into R, it can be viewed in Excel or a text editor.\n\n1.1\nUse the read.csv() function to read the data into R. Call the loaded data college. Make sure that you have the directory set to the correct location for the data.\n\n\n1.2\nLook at the data using the View() function. You should notice that the first column is just the name of each university. We don’t really want R to treat this as data. However, it may be handy to have these names for later. Try the following commands:\n\n# try this\n# rownames(college) <- college[, 1]\n# View(college) \n\nYou should see that there is now a row.names column with the name of each university recorded. This means that R has given each row a name corresponding to the appropriate university. R will not try to perform calculations on the row names. However, we still need to eliminate the first column in the data where the names are stored. Try\n\n# try this\n# college <- college[, 1]\n# View(college) \n\nNow you should see that the first data column is Private. Note that another column labeled row.names now appears before the Private column. However, this is not a data column but rather the name that R is giving to each row.\n\n\n1.3\nUse the summary() function to produce a numerical summary of the variables in the data set.\n\n\n1.4\nUse the pairs() function to produce a scatterplot matrix of the first ten columns or variables of the data. Recall that you can reference the first ten columns of a matrix A using A[,1:10].\n\n\n1.5\nUse the plot() function to produce side-by-side boxplots of Outstate versus Private. Briefly interpret the information the graph conveys.\n\n\n1.6\nCreate a new qualitative variable, called Elite, by binning the Top10perc variable. We are going to divide universities into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%.\n\n\n1.7\nUse the summary() function to see how many elite universities there are. Now use the plot() function to produce side-by-side boxplots of Outstate versus Elite. Briefly interpret the information the graph conveys.\n\n\n1.8\nUse the hist() function to produce some histograms with differing numbers of bins for a few of the quantitative variables. You may find the command par(mfrow = c(2, 2)) useful: it will divide the print window into four regions so that four plots can be made simultaneously. Modifying the arguments to this function will divide the screen in other ways."
  },
  {
    "objectID": "lab06-mod-selection.html",
    "href": "lab06-mod-selection.html",
    "title": "Lab 06 Model selection",
    "section": "",
    "text": "Here we apply the best subset selection approach to the Hitters data. We wish to predict a baseball player’s Salary on the basis of various statistics associated with performance in the previous year.\n\n\n\nFirst of all, we note that the Salary variable is missing for some of the players. The is.na() function can be used to identify the missing observations. It returns a vector of the same length as the input vector, with a TRUE for any elements that are missing, and a FALSE for non-missing elements.\nThe sum() function can then be used to count all of the missing elements.\n\nlibrary (ISLR2)\n\nWarning: package 'ISLR2' was built under R version 4.1.1\n\n# View(Hitters) \nnames(Hitters) \n\n [1] \"AtBat\"     \"Hits\"      \"HmRun\"     \"Runs\"      \"RBI\"       \"Walks\"    \n [7] \"Years\"     \"CAtBat\"    \"CHits\"     \"CHmRun\"    \"CRuns\"     \"CRBI\"     \n[13] \"CWalks\"    \"League\"    \"Division\"  \"PutOuts\"   \"Assists\"   \"Errors\"   \n[19] \"Salary\"    \"NewLeague\"\n\ndim(Hitters) \n\n[1] 322  20\n\nsum(is.na(Hitters$Salary))\n\n[1] 59\n\n\nHence we see that Salary is missing for 59 players. The na.omit() function removes all of the rows that have missing values in any variable.\n\nHitters <- na.omit(Hitters)\ndim(Hitters) \n\n[1] 263  20\n\nsum(is.na(Hitters))\n\n[1] 0\n\n\n\n\n\nThe regsubsets() function (part of the leaps library) performs best subset selection by identifying the best model that contains a given number of predictors, where best is quantified using RSS. The syntax is the same as for lm(). The summary() command outputs the best set of variables for each model size.\n\nlibrary(leaps)\n\nWarning: package 'leaps' was built under R version 4.1.2\n\nregfit.full <- regsubsets(Salary ~ ., Hitters)\nsummary(regfit.full) \n\nSubset selection object\nCall: regsubsets.formula(Salary ~ ., Hitters)\n19 Variables  (and intercept)\n           Forced in Forced out\nAtBat          FALSE      FALSE\nHits           FALSE      FALSE\nHmRun          FALSE      FALSE\nRuns           FALSE      FALSE\nRBI            FALSE      FALSE\nWalks          FALSE      FALSE\nYears          FALSE      FALSE\nCAtBat         FALSE      FALSE\nCHits          FALSE      FALSE\nCHmRun         FALSE      FALSE\nCRuns          FALSE      FALSE\nCRBI           FALSE      FALSE\nCWalks         FALSE      FALSE\nLeagueN        FALSE      FALSE\nDivisionW      FALSE      FALSE\nPutOuts        FALSE      FALSE\nAssists        FALSE      FALSE\nErrors         FALSE      FALSE\nNewLeagueN     FALSE      FALSE\n1 subsets of each size up to 8\nSelection Algorithm: exhaustive\n         AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI\n1  ( 1 ) \" \"   \" \"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n2  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n3  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n4  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n5  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n6  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n7  ( 1 ) \" \"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \"*\"   \"*\"    \" \"   \" \" \n8  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \"*\"    \"*\"   \" \" \n         CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN\n1  ( 1 ) \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n2  ( 1 ) \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n3  ( 1 ) \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n4  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n5  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n6  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n7  ( 1 ) \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n8  ( 1 ) \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n\n\nAn asterisk indicates that a given variable is included in the corresponding model. For instance, this output indicates that the best two-variable model contains only Hits and CRBI. By default, regsubsets() only reports results up to the best eight-variable model. But the nvmax option can be used in order to return as many variables as are desired. Here we fit up to a 19-variable model.\n\n\n\n\nregfit.full <- regsubsets(Salary ~ ., \n                          data = Hitters,\n                          nvmax = 19)\n\nreg.summary <- summary(regfit.full)\n\nThe summary()function also returns \\(R^2\\), RSS, adjusted \\(R^2\\), \\(C_p\\), and BIC. We can examine these to try to select the best overall model.\n\nnames(reg.summary)\n\n[1] \"which\"  \"rsq\"    \"rss\"    \"adjr2\"  \"cp\"     \"bic\"    \"outmat\" \"obj\"   \n\nreg.summary$rsq\n\n [1] 0.3214501 0.4252237 0.4514294 0.4754067 0.4908036 0.5087146 0.5141227\n [8] 0.5285569 0.5346124 0.5404950 0.5426153 0.5436302 0.5444570 0.5452164\n[15] 0.5454692 0.5457656 0.5459518 0.5460945 0.5461159\n\n\nFor instance, we see that the \\(R^2\\) statistic increases from 32%, when only one variable is included in the model, to almost 55%, when all variables are included. As expected, the \\(R^2\\) statistic increases monotonically as more variables are included.\nPlotting RSS, adjusted \\(R^2\\), \\(C_p\\), and BIC for all of the models at once will help us decide which model to select. Note the type = \"l\" option tells R to connect the plotted points with lines.\n\npar(mfrow = c(2, 2))\n\nplot(reg.summary$rss, \n     xlab = \"Number of Variables\", \n     ylab = \"RSS \", \n     type = \"l\")\nplot(reg.summary$adjr2, \n     xlab = \"Number of Variables\", \n     ylab = \"Adjusted RSq\", \n     type = \"l\")\n\nwhich.max(reg.summary$adjr2)\n\n[1] 11\n\npoints(11, reg.summary$adjr2[11], \n       col = \"red\", cex = 2 , pch = 20)\n\nplot(reg.summary$cp, \n     xlab = \"Number of Variables\", \n     ylab = \"Cp\", \n     type = \"l\")\n\nwhich.min(reg.summary$cp)\n\n[1] 10\n\npoints(10, reg.summary$cp[10],\n       col = \"red\", cex = 2, pch = 20)\n\nwhich.min(reg.summary$bic)\n\n[1] 6\n\nplot(reg.summary$bic, xlab = \"Number of Variables\", \n     ylab = \"BIC\", type = \"l\")\npoints (6, reg.summary$bic[6], \n        col = \"red\", cex = 2, pch = 20)\n\n\n\npar(mfrow = c(1, 1))\n\n\n\n\nThe points() command works like the plot() command, except that it puts points on a plot that has already been created, instead of creating a new plot. The which.max() function can be used to identify the location of the maximum point of a vector. We will now plot a red dot to indicate the model with the largest adjusted \\(R^2\\) statistic.\n\n\n\n\n# for each plot, one row per model\n\npar(mfrow = c(2, 2))\n\nplot(regfit.full, scale = \"r2\")\nplot(regfit.full, scale = \"adjr2\")\nplot(regfit.full, scale = \"Cp\")\nplot(regfit.full, scale = \"bic\")\n\n\n\npar(mfrow = c(1, 1))\n\nThe top row of each plot contains a black square for each variable selected according to the optimal model associated with that statistic. For instance, we see that several models share a BIC close to -150. However, the model with the lowest BIC is the six-variable model that contains only AtBat, Hits, Walks, CRBI, DivisionW, and PutOuts. We can use the coef() function to see the coeﬃcient estimates associated with this model.\n\ncoef(regfit.full, 6) \n\n (Intercept)        AtBat         Hits        Walks         CRBI    DivisionW \n  91.5117981   -1.8685892    7.6043976    3.6976468    0.6430169 -122.9515338 \n     PutOuts \n   0.2643076"
  },
  {
    "objectID": "lab06-mod-selection.html#stepwise-regression",
    "href": "lab06-mod-selection.html#stepwise-regression",
    "title": "Lab 06 Model selection",
    "section": "2 Stepwise regression",
    "text": "2 Stepwise regression\nWe can also use the regsubsets() function to perform forward stepwise, or backward stepwise selection, using the argument method = \"forward\" or method = \"backward\".\n\nregfit.fwd <- regsubsets(Salary ~ ., data = Hitters,\n                         nvmax = 19, method = \"forward\")\nsummary(regfit.fwd )\n\nSubset selection object\nCall: regsubsets.formula(Salary ~ ., data = Hitters, nvmax = 19, method = \"forward\")\n19 Variables  (and intercept)\n           Forced in Forced out\nAtBat          FALSE      FALSE\nHits           FALSE      FALSE\nHmRun          FALSE      FALSE\nRuns           FALSE      FALSE\nRBI            FALSE      FALSE\nWalks          FALSE      FALSE\nYears          FALSE      FALSE\nCAtBat         FALSE      FALSE\nCHits          FALSE      FALSE\nCHmRun         FALSE      FALSE\nCRuns          FALSE      FALSE\nCRBI           FALSE      FALSE\nCWalks         FALSE      FALSE\nLeagueN        FALSE      FALSE\nDivisionW      FALSE      FALSE\nPutOuts        FALSE      FALSE\nAssists        FALSE      FALSE\nErrors         FALSE      FALSE\nNewLeagueN     FALSE      FALSE\n1 subsets of each size up to 19\nSelection Algorithm: forward\n          AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI\n1  ( 1 )  \" \"   \" \"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n2  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n3  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n4  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n5  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n6  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n7  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \" \"   \"*\" \n8  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \"*\" \n9  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n10  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n11  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n12  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n13  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n14  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n15  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n16  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n17  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n18  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n19  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \"*\"    \"*\"   \"*\" \n          CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN\n1  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n2  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n3  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n4  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n5  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n6  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n7  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n8  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n9  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n10  ( 1 ) \"*\"    \" \"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n11  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n12  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n13  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n14  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n15  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n16  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n17  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n18  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n19  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n\nregfit.bwd <- regsubsets(Salary ~ ., data = Hitters, \n                         nvmax = 19 , method = \"backward\")\nsummary(regfit.bwd )\n\nSubset selection object\nCall: regsubsets.formula(Salary ~ ., data = Hitters, nvmax = 19, method = \"backward\")\n19 Variables  (and intercept)\n           Forced in Forced out\nAtBat          FALSE      FALSE\nHits           FALSE      FALSE\nHmRun          FALSE      FALSE\nRuns           FALSE      FALSE\nRBI            FALSE      FALSE\nWalks          FALSE      FALSE\nYears          FALSE      FALSE\nCAtBat         FALSE      FALSE\nCHits          FALSE      FALSE\nCHmRun         FALSE      FALSE\nCRuns          FALSE      FALSE\nCRBI           FALSE      FALSE\nCWalks         FALSE      FALSE\nLeagueN        FALSE      FALSE\nDivisionW      FALSE      FALSE\nPutOuts        FALSE      FALSE\nAssists        FALSE      FALSE\nErrors         FALSE      FALSE\nNewLeagueN     FALSE      FALSE\n1 subsets of each size up to 19\nSelection Algorithm: backward\n          AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI\n1  ( 1 )  \" \"   \" \"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n2  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n3  ( 1 )  \" \"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n4  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \" \"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n5  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n6  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n7  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \" \" \n8  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \" \"    \" \"   \" \"    \"*\"   \"*\" \n9  ( 1 )  \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n10  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n11  ( 1 ) \"*\"   \"*\"  \" \"   \" \"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n12  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n13  ( 1 ) \"*\"   \"*\"  \" \"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n14  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \" \"   \" \"    \"*\"   \"*\" \n15  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \" \" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n16  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n17  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \" \"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n18  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \" \"    \"*\"   \"*\" \n19  ( 1 ) \"*\"   \"*\"  \"*\"   \"*\"  \"*\" \"*\"   \"*\"   \"*\"    \"*\"   \"*\"    \"*\"   \"*\" \n          CWalks LeagueN DivisionW PutOuts Assists Errors NewLeagueN\n1  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n2  ( 1 )  \" \"    \" \"     \" \"       \" \"     \" \"     \" \"    \" \"       \n3  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n4  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n5  ( 1 )  \" \"    \" \"     \" \"       \"*\"     \" \"     \" \"    \" \"       \n6  ( 1 )  \" \"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n7  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n8  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n9  ( 1 )  \"*\"    \" \"     \"*\"       \"*\"     \" \"     \" \"    \" \"       \n10  ( 1 ) \"*\"    \" \"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n11  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n12  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \" \"    \" \"       \n13  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n14  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n15  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n16  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \" \"       \n17  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n18  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n19  ( 1 ) \"*\"    \"*\"     \"*\"       \"*\"     \"*\"     \"*\"    \"*\"       \n\n\nFor instance, we see that using forward stepwise selection, the best one-variable model contains only CRBI, and the best two-variable model additionally includes Hits. For this data, the best one-variable through six- variable models are each identical for best subset and forward selection. However, the best seven-variable models identified by forward stepwise selection, backward stepwise selection, and best subset selection are different.\n\nrbind(\n  coef(regfit.full, 7),\n  coef(regfit.fwd, 7),\n  coef(regfit.bwd, 7) )\n\n     (Intercept)      Hits    Walks    CAtBat     CHits     CHmRun DivisionW\n[1,]    79.45095  1.283351 3.227426 -0.375235 1.4957073  1.4420538 -129.9866\n[2,]   109.78731 -1.958885 7.449877  4.913140 0.8537622 -0.3053070 -127.1224\n[3,]   105.64875 -1.976284 6.757491  6.055869 1.1293095 -0.7163346 -116.1692\n       PutOuts\n[1,] 0.2366813\n[2,] 0.2533404\n[3,] 0.3028847"
  },
  {
    "objectID": "lab06-mod-selection.html#validation-sets-for-model-selection",
    "href": "lab06-mod-selection.html#validation-sets-for-model-selection",
    "title": "Lab 06 Model selection",
    "section": "3 Validation sets for model selection",
    "text": "3 Validation sets for model selection\nSo, it is possible to choose among a set of models of diﬀerent sizes using \\(C_p\\), BIC, and adjusted \\(R^2\\). We will now consider how to do this using the validation set and cross-validation approaches.\nIn order for these approaches to yield accurate estimates of the test error, we must use only the training observations to perform all aspects of model fitting, including variable selection. Therefore, the determination of which model of a given size is best must be made using only the training observations. This point is subtle but important.\nIf the full data set is used to perform the best subset selection step, the validation set errors and cross-validation errors that we obtain will not be accurate estimates of the test error.\nIn order to use the validation set approach, we begin by splitting the observations into a training set and a test set. We do this by creating a random vector, train, of elements equal to TRUE if the corresponding observation is in the training set, and FALSE otherwise. The vector test has a TRUE if the observation is in the test set, and a FALSE otherwise. Note the ! in the command to create test causes TRUEs to be switched to FALSEs and vice versa. We also set a random seed so that you can obtain the same training set/test set split, i.e so that you analysis will be repeatable.\n\nset.seed(1)\ntrain <- sample(c(TRUE, FALSE), nrow (Hitters), replace = TRUE )\ntest <- (!train)\n\nNow, we apply regsubsets() to the training set in order to perform best subset selection.\n\nregfit.best <- regsubsets(Salary ~ .,\n                          data = Hitters[train, ], nvmax = 19)\n\nNotice that we subset the Hitters data frame directly in the call in order to access only the training subset of the data, using the expression Hitters[train, ]. We now compute the validation set error for the best model of each model size. We first make a model matrix from the test data.\n\nmodel.matrix()\n\ntest.mat <- model.matrix(Salary ~., data = Hitters[test, ]) \n\nThe model.matrix() function is used in many regression packages for building an “X” matrix from data. Now we run a loop, and for each size i, we extract the coeﬃcients from regfit.best for the best model of that size, multiply them into the appropriate columns of the test model matrix to form the predictions, and compute the test MSE.\n\nval.errors <- rep(NA, 19)\nfor(i in 1:19) {\n  coefi <- coef(regfit.best, id = i)\n  pred <- test.mat [ , names(coefi)] %*% coefi\n  val.errors[i] <- mean ((Hitters$Salary[test] - pred )^2)\n}\n\nWe find that the best model is the one that contains seven variables.\n\nval.errors\n\n [1] 164377.3 144405.5 152175.7 145198.4 137902.1 139175.7 126849.0 136191.4\n [9] 132889.6 135434.9 136963.3 140694.9 140690.9 141951.2 141508.2 142164.4\n[17] 141767.4 142339.6 142238.2\n\nwhich.min(val.errors)\n\n[1] 7\n\ncoef(regfit.best, 7)\n\n (Intercept)        AtBat         Hits        Walks        CRuns       CWalks \n  67.1085369   -2.1462987    7.0149547    8.0716640    1.2425113   -0.8337844 \n   DivisionW      PutOuts \n-118.4364998    0.2526925 \n\n# we can graph it too\npar(mfrow = c(1,1))\nplot(val.errors, type = 'b', \n     pch = 16, col = 'goldenrod',\n     main = \"Lower is better\")\n\n\n\n\n\n\nAutomating it\nThis was a little tedious, partly because there is no predict() method for regsubsets(). Since we will be using this function again, we can capture our steps above and write our own predict method.\n\npredict.regsubsets <- function(object, newdata , id , ...) {\n  form <- as.formula(object$ call[[ 2 ]])\n  mat <- model.matrix (form, newdata )\n  coefi <- coef (object , id = id)\n  xvars <- names (coefi) \n  mat [, xvars ] %*% coefi\n  }\n\nThis function pretty much mimics what we did above. The only complex part is how we extracted the formula used in the call to regsubsets(). We wioll explore how we use this function below, when we do cross-validation.\nFinally, we perform best subset selection on the full data set, and select the best seven-variable model. It is important that we make use of the full data set in order to obtain more accurate coefficient estimates. Note that we perform best subset selection on the full data set and select the best seven-variable model, rather than simply using the variables that were obtained from the training set, because the best seven-variable model on the full data set may diﬀer from the corresponding model on the training set.\n\nregfit.best <- regsubsets(Salary ~ ., \n                          data = Hitters, nvmax = 19)\ncoef(regfit.best, 7)\n\n (Intercept)         Hits        Walks       CAtBat        CHits       CHmRun \n  79.4509472    1.2833513    3.2274264   -0.3752350    1.4957073    1.4420538 \n   DivisionW      PutOuts \n-129.9866432    0.2366813 \n\n\nIn fact, we see that the best seven-variable model on the full data set has a diﬀerent set of variables than the best seven-variable model on the training set.\n\n\nCross-val\nWe now try to choose among the models of diﬀerent sizes using cross- validation. This approach is somewhat involved, as we must perform best subset selection within each of the k training sets. Despite this, we see that with its clever subsetting syntax, R makes this job quite easy. First, we create a vector that allocates each observation to one of k = 10 folds, and we create a matrix in which we will store the results.\n\nk <- 10\nn <- nrow(Hitters) \n\nset.seed(1)\nfolds <- sample(rep(1:k, length = n))\n\ncv.errors <- matrix (NA, k, 19, dimnames = list (NULL, paste (1:19)))\n\nNow we write a for loop that performs cross-validation. In the \\(j_{th}\\) fold, the elements of folds that equal j are in the test set, and the remainder are in the training set. We make our predictions for each model size (using our new predict() method), compute the test errors on the appropriate subset, and store them in the appropriate slot in the matrix cv.errors. Note that in the following code R will automatically use our predict.regsubsets() function when we call predict() because the best.fit object has class regsubsets.\n\n\nNested for() loops\n\nfor(j in 1:k){\n  best.fit <- regsubsets(Salary ~ .,\n                            data = Hitters[folds != j, ], nvmax = 19)\n  for (i in 1: 19) {\n    pred <- predict(best.fit, Hitters[ folds == j, ], id = i)\n    cv.errors[j, i] <- mean((Hitters$Salary[folds == j] - pred )^2)\n  }\n}\n\nThis has given us a 10 \\(\\times\\) 19 matrix, of which the (j, i)th element corresponds to the test MSE for the \\(j_{th}\\) cross-validation fold for the best j-variable model. We use the apply() function to average over the columns of this matrix in order to obtain a vector for which the \\(i_{th}\\) element is the cross-validation error for the i-variable model.\n\nmean.cv.errors <- apply(cv.errors ,2 , mean)\nmean.cv.errors\n\n       1        2        3        4        5        6        7        8 \n143439.8 126817.0 134214.2 131782.9 130765.6 120382.9 121443.1 114363.7 \n       9       10       11       12       13       14       15       16 \n115163.1 109366.0 112738.5 113616.5 115557.6 115853.3 115630.6 116050.0 \n      17       18       19 \n116117.0 116419.3 116299.1 \n\npar(mfrow = c(1 , 1))\nplot(mean.cv.errors, type = \"b\",\n     pch = 16, col = 'goldenrod')\n\n\n\n\nWe see that cross-validation selects a 10-variable model. We now perform best subset selection on the full data set in order to obtain the 10-variable model.\n\nreg.best <- regsubsets(Salary ~ ., data = Hitters,\n                       nvmax = 19)\ncoef(reg.best, 10)          \n\n (Intercept)        AtBat         Hits        Walks       CAtBat        CRuns \n 162.5354420   -2.1686501    6.9180175    5.7732246   -0.1300798    1.4082490 \n        CRBI       CWalks    DivisionW      PutOuts      Assists \n   0.7743122   -0.8308264 -112.3800575    0.2973726    0.2831680 \n\n\n\n# It is always a good idea to examine the coefficients graphically\n\npar(mfrow=c(1,2))\n\nplot(Salary ~ Hits, data = Hitters)\nabline(lm(Salary ~ Hits, data = Hitters))\n\nplot(Salary ~ Walks, data = Hitters)\nabline(lm(Salary ~ Hits, data = Hitters))\n\n\n\npar(mfrow=c(1,1))"
  },
  {
    "objectID": "lab06-mod-selection.html#ridge-regression-and-lasso",
    "href": "lab06-mod-selection.html#ridge-regression-and-lasso",
    "title": "Lab 06 Model selection",
    "section": "4 Ridge regression and lasso",
    "text": "4 Ridge regression and lasso\n\nglmnet()\nWe will use the {glmnet} package in order to perform ridge regression and the lasso. The main function in this package is glmnet(), which can be used to fit ridge regression models, lasso models, and more. This function has slightly diﬀerent syntax from other model-fitting functions that we have encountered thus far in this book. In particular, we must pass in an x matrix as well as a y vector, and we do not use the y ∼ x syntax. We will now perform ridge regression and the lasso in order to predict Salary on the Hitters data. Before proceeding ensure that the missing values have been removed from the data.\n\n# data prep\nx <- model.matrix(Salary ~ ., Hitters )[, -1]\ny <- Hitters$Salary\n\nThe model.matrix() function is particularly useful for creating x; not only does it produce a matrix corresponding to the 19 predictors but it also automatically transforms any qualitative variables into dummy variables. The latter property is important because glmnet() can only take numerical, quantitative inputs.\n\n\nRidge reg.\nThe glmnet() function has an alpha argument that determines what type of model is fit. If alpha=0 then a ridge regression model is fit, and if alpha=1 then a lasso model is fit. We first fit a ridge regression model.\n\nlibrary(glmnet) \n\nWarning: package 'glmnet' was built under R version 4.1.2\n\n\nLoading required package: Matrix\n\n\nLoaded glmnet 4.1-3\n\ngrid <- 10^seq(10 , -2 , length = 100)\nridge.mod <- glmnet(x, y, alpha = 0 , lambda = grid )\n\nBy default the glmnet() function performs ridge regression for an automatically selected range of \\(\\lambda\\) values. However, here we have chosen to implement the function over a grid of values ranging from \\(\\lambda=1010\\) to \\(\\lambda = 10^2\\), essentially covering the full range of scenarios from the null model containing only the intercept, to the least squares fit. As we will see, we can also compute model fits for a particular value of \\(\\lambda\\) that is not one of the original grid values. Note that by default, the glmnet() function standardizes the variables so that they are on the same scale. To turn off this default setting, use the argument standardize = FALSE.\nAssociated with each value of \\(\\lambda\\) is a vector of ridge regression coefficients, stored in a matrix that can be accessed by coef(). In this case, it is a 20 \\(\\times\\) 100 matrix, with 20 rows (one for each predictor, plus an intercept) and 100 columns (one for each value of \\(\\lambda\\)).\n\ndim(coef(ridge.mod ))\n\n[1]  20 100\n\n\nWe expect the coefficient estimates to be much smaller, in terms of \\(\\ell_2\\) norm, when a large value of \\(\\lambda\\) is used, as compared to when a small value of \\(\\lambda\\) is used. These are the coefficients when\\(\\lambda = 11,498\\), along with their \\(\\ell_2\\) norm:\n\nridge.mod$lambda[50]\n\n[1] 11497.57\n\nsqrt(sum(coef(ridge.mod )[-1 , 50]^2))\n\n[1] 6.360612\n\n\nIn contrast, here are the coeﬃcients when \\(\\lambda=705\\), along with their \\(\\ell_2\\) norm. Note the much larger \\(\\ell_2\\) norm of the coeﬃcients associated with this smaller value of \\(\\lambda\\).\n\nridge.mod$lambda[60] # lambda\n\n[1] 705.4802\n\ncoef(ridge.mod )[ , 60]\n\n (Intercept)        AtBat         Hits        HmRun         Runs          RBI \n 54.32519950   0.11211115   0.65622409   1.17980910   0.93769713   0.84718546 \n       Walks        Years       CAtBat        CHits       CHmRun        CRuns \n  1.31987948   2.59640425   0.01083413   0.04674557   0.33777318   0.09355528 \n        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists \n  0.09780402   0.07189612  13.68370191 -54.65877750   0.11852289   0.01606037 \n      Errors   NewLeagueN \n -0.70358655   8.61181213 \n\nsqrt(sum(coef(ridge.mod)[-1 , 60 ]^2 ))\n\n[1] 57.11001\n\n\n\n\nRidge predict()\nWe can use the predict() function for a number of purposes. For instance, we can obtain the ridge regression coeﬃcients for a new value of \\(\\lambda\\), say 50:\n\npredict(ridge.mod, s = 50, type = \"coefficients\")[1:20, ]\n\n  (Intercept)         AtBat          Hits         HmRun          Runs \n 4.876610e+01 -3.580999e-01  1.969359e+00 -1.278248e+00  1.145892e+00 \n          RBI         Walks         Years        CAtBat         CHits \n 8.038292e-01  2.716186e+00 -6.218319e+00  5.447837e-03  1.064895e-01 \n       CHmRun         CRuns          CRBI        CWalks       LeagueN \n 6.244860e-01  2.214985e-01  2.186914e-01 -1.500245e-01  4.592589e+01 \n    DivisionW       PutOuts       Assists        Errors    NewLeagueN \n-1.182011e+02  2.502322e-01  1.215665e-01 -3.278600e+00 -9.496680e+00 \n\n\n\n\nTest error\nWe now split the samples into a training set and a test set in order to estimate the test error of ridge regression and the lasso. There are two common ways to randomly split a data set. The first is to produce a random vector of TRUE, FALSE elements and select the observations corresponding to TRUE for the training data. The second is to randomly choose a subset of numbers between 1 and n; these can then be used as the indices for the training observations. The two approaches work equally well.\nHere we will demonstrate the latter approach. We first set a random seed so that the results obtained will be reproducible.\n\nset.seed(1)\ntrain <- sample(1:nrow (x), nrow(x)/2)\ntest <- (-train )\ny.test <- y[test]\n\nNext we fit a ridge regression model on the training set, and evaluate its MSE on the test set, using \\(\\lambda = 4\\). Note the use of the predict() function again. This time we get predictions for a test set, by replacing type=\"coefficients\" with the newx argument.\n\nridge.mod <- glmnet(x[train, ], y[train], alpha = 0, lambda = grid , thresh = 1e-12)\nridge.pred <- predict(ridge.mod, s = 4, newx = x[ test, ])\nmean((ridge.pred - y.test)^2)\n\n[1] 142199.2\n\n\n\n\nExplore model results space\nThe test MSE is 142,199. Note that if we had instead simply fit a model with just an intercept, we would have predicted each test observation using the mean of the training observations. In that case, we could compute the test set MSE like this:\n\nmean((mean(y[train ]) - y.test)^2)\n\n[1] 224669.9\n\n\nWe could also get the same result by fitting a ridge regression model with a very large value of \\(\\lambda\\). Note that 1e10 means \\(10^10\\).\n\nridge.pred <- predict(ridge.mod, s = 1e10, newx = x[test, ])\nmean((ridge.pred - y.test )^2)\n\n[1] 224669.8\n\n\nSo fitting a ridge regression model with \\(\\lambda = 4\\) leads to a much lower test MSE than fitting a model with just an intercept. We now check whether there is any benefit to performing ridge regression with \\(\\lambda = 4\\) instead of just performing least squares regression. Recall that least squares is simply ridge regression with \\(\\lambda = 0\\)\nIn order for glmnet() to yield the exact least squares coeﬃcients when λ = 0, we use the argument exact = T when calling the predict() function. Otherwise, the predict() function will interpolate over the grid of \\(\\lambda\\) values used in fitting the glmnet() model, yielding approximate results. When we use exact = T, there remains a slight discrepancy in the third decimal place between the output of glmnet() when \\(\\lambda = 0\\) and the output of lm(); this is due to numerical approximation on the part of glmnet().\n\nridge.pred <- predict(ridge.mod, s = 0, \n                      newx = x[test, ], exact = T, \n                      x = x[train , ], y = y[ train ])\nmean((ridge.pred - y.test )^2)\n\n[1] 168588.6\n\nlm(y ~ x, subset = train )\n\n\nCall:\nlm(formula = y ~ x, subset = train)\n\nCoefficients:\n(Intercept)       xAtBat        xHits       xHmRun        xRuns         xRBI  \n   274.0145      -0.3521      -1.6377       5.8145       1.5424       1.1243  \n     xWalks       xYears      xCAtBat       xCHits      xCHmRun       xCRuns  \n     3.7287     -16.3773      -0.6412       3.1632       3.4008      -0.9739  \n      xCRBI      xCWalks     xLeagueN   xDivisionW     xPutOuts     xAssists  \n    -0.6005       0.3379     119.1486    -144.0831       0.1976       0.6804  \n    xErrors  xNewLeagueN  \n    -4.7128     -71.0951  \n\npredict(ridge.mod, s = 0, exact = T, type = \"coefficients\", \n        x = x[train, ], y = y[train])[1:20 , ]\n\n (Intercept)        AtBat         Hits        HmRun         Runs          RBI \n 274.0200994   -0.3521900   -1.6371383    5.8146692    1.5423361    1.1241837 \n       Walks        Years       CAtBat        CHits       CHmRun        CRuns \n   3.7288406  -16.3795195   -0.6411235    3.1629444    3.4005281   -0.9739405 \n        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists \n  -0.6003976    0.3378422  119.1434637 -144.0853061    0.1976300    0.6804200 \n      Errors   NewLeagueN \n  -4.7127879  -71.0898914 \n\n\n\n\ncv.glmnet()\nIn general, if we want to fit a (unpenalized) least squares model, then we should use the lm() function, since that function provides more useful outputs, such as standard errors and p-values for the coefficients.\nIn general, instead of arbitrarily choosing \\(\\lambda = 4\\), it would be better to use cross-validation to choose the tuning parameter \\(\\lambda\\). We can do this using the built-in cross-validation function, cv.glmnet(). By default, the function performs ten-fold cross-validation, though this can be changed using the argument nfolds. Note that we set a random seed first so our results will be reproducible, since the choice of the cross-validation folds is random.\n\nset.seed(1)\ncv.out <- cv.glmnet(x[train, ], y[train], alpha = 0)\npar(mfrow=c(1,1))\nplot(cv.out )\n\n\n\nbestlam <- cv.out$lambda.min\nbestlam\n\n[1] 326.0828\n\n\nTherefore, we see that the value of \\(\\lambda\\) that results in the smallest cross- validation error is 326 (log(326) = ~5.8 on the graph). What is the test MSE associated with this value of \\(\\lambda\\)?\n\nridge.pred <- predict(ridge.mod, s = bestlam, newx = x[test, ])\nmean((ridge.pred - y.test)^2)\n\n[1] 139856.6\n\n\nThis represents a further improvement over the test MSE that we got using \\(\\lambda = 4\\). Finally, we refit our ridge regression model on the full data set, using the value of \\(\\lambda\\) chosen by cross-validation, and examine the coeﬃcient estimates.\n\nout <- glmnet(x, y, alpha = 0)\npredict(out, type = \"coefficients\", s = bestlam)[1:20, ]\n\n (Intercept)        AtBat         Hits        HmRun         Runs          RBI \n 15.44383120   0.07715547   0.85911582   0.60103106   1.06369007   0.87936105 \n       Walks        Years       CAtBat        CHits       CHmRun        CRuns \n  1.62444617   1.35254778   0.01134999   0.05746654   0.40680157   0.11456224 \n        CRBI       CWalks      LeagueN    DivisionW      PutOuts      Assists \n  0.12116504   0.05299202  22.09143197 -79.04032656   0.16619903   0.02941950 \n      Errors   NewLeagueN \n -1.36092945   9.12487765 \n\n\nAs expected, none of the coeﬃcients are zero—ridge regression does not perform variable selection!"
  },
  {
    "objectID": "lab06-mod-selection.html#the-lasso",
    "href": "lab06-mod-selection.html#the-lasso",
    "title": "Lab 06 Model selection",
    "section": "5 The lasso",
    "text": "5 The lasso\nWe saw that ridge regression with a wise choice of \\(\\lambda\\) can outperform least squares as well as the null model on the Hitters data set. We now ask whether the lasso can yield either a more accurate or a more interpretable model than ridge regression. In order to fit a lasso model, we once again use the glmnet() function; however, this time we use the argument alpha=1. Other than that change, we proceed just as we did in fitting a ridge model.\n\nlasso.mod <- glmnet(x[train, ], y[train ], alpha = 1, lambda = grid )\nplot(lasso.mod )\n\n\n\n\nWe can see from the coefficient plot that depending on the choice of tuning parameter, some of the coefficients will be exactly equal to zero. We now perform cross-validation and compute the associated test error.\n\nset.seed(1)\ncv.out <- cv.glmnet(x[train , ], y[train ], alpha = 1)\nplot(cv.out )\n\n\n\nbestlam <- cv.out$lambda.min\nlasso.pred <- predict(lasso.mod , s = bestlam , newx = x[test, ])\nmean((lasso.pred - y.test)^2)\n\n[1] 143673.6\n\n\nThis is substantially lower than the test set MSE of the null model and of least squares, and very similar to the test MSE of ridge regression with \\(\\lambda\\) chosen by cross-validation.\nHowever, the lasso has a substantial advantage over ridge regression in that the resulting coefficient estimates are sparse. Here we see that 8 of the 19 coeﬃcient estimates are exactly zero. So the lasso model with \\(\\lambda\\) chosen by cross-validation contains only eleven variables. This results in a model that tends to be both easier to compute, and easier to interpret.\n\nout <- glmnet (x, y, alpha = 1, lambda = grid )\nlasso.coef <- predict(out, type = \"coefficients\", s = bestlam )[1:20, ]\nlasso.coef\n\n  (Intercept)         AtBat          Hits         HmRun          Runs \n   1.27479059   -0.05497143    2.18034583    0.00000000    0.00000000 \n          RBI         Walks         Years        CAtBat         CHits \n   0.00000000    2.29192406   -0.33806109    0.00000000    0.00000000 \n       CHmRun         CRuns          CRBI        CWalks       LeagueN \n   0.02825013    0.21628385    0.41712537    0.00000000   20.28615023 \n    DivisionW       PutOuts       Assists        Errors    NewLeagueN \n-116.16755870    0.23752385    0.00000000   -0.85629148    0.00000000"
  },
  {
    "objectID": "lab06-mod-selection.html#exercises",
    "href": "lab06-mod-selection.html#exercises",
    "title": "Lab 06 Model selection",
    "section": "8 Exercises",
    "text": "8 Exercises\n\nExercise 1\nFor the next few questions, we will generate simulated data, and will then use this data to perform best subset selection.\n\n1.1\nUse the rnorm() function to generate a predictor X of length n = 100, as well as a noise vector \\(\\epsilon\\) of length n = 100.\n\n\n1.2\nGenerate a response vector Y of length n = 100 according to the model\n\\(Y=\\beta_0 + \\beta_1 X + \\beta_2 X^2 + \\beta_3 X^3 + \\epsilon\\)\nwhere \\(Y=\\beta_0\\), \\(\\beta_1\\), \\(\\beta_2\\), and \\(\\beta_3\\) are constants of your choice\n\n\n1.3\nUse the regsubsets() function to perform best subset selection in order to choose the best model containing the predictors \\(X\\), \\(X^2\\),. .., \\(X^{10}\\). What is the best model obtained according to \\(C_p\\), BIC, and adjusted \\(R^2\\)? Show some plots to provide evidence for your answer, and report the coeﬃcients of the best model obtained. Note you will need to use the data.frame() function to create a single data set containing both X and Y.\n\n\n1.4\nRepeat 1.3, using forward stepwise selection and also using backwards stepwise selection. How does your answer compare to the results in 1.3?\n\n\n1.5\nNow fit a lasso model to the simulated data, again using \\(X\\), \\(X^2\\),. .., \\(X^{10}\\) as predictors. Use cross-validation to select the optimal value of \\(\\lambda\\). Create plots of the cross-validation error as a function of \\(\\lambda\\). Report the resulting coefficient estimates, and discuss the results obtained.\n\n\n1.6\nNow generate a response vector \\(Y\\) according to the model\n\\(Y = \\beta_0 + \\beta_7X^7 + \\epsilon\\),\nand perform best subset selection and the lasso. Discuss the results obtained."
  },
  {
    "objectID": "lab06-mod-selection.html#resources",
    "href": "lab06-mod-selection.html#resources",
    "title": "Lab 06 Model selection",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "lab06-mod-selection.html#harper-adams-data-science",
    "href": "lab06-mod-selection.html#harper-adams-data-science",
    "title": "Lab 06 Model selection",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab06-mod-selection.html#pcr",
    "href": "lab06-mod-selection.html#pcr",
    "title": "Lab 06 Model selection",
    "section": "6 PCR",
    "text": "6 PCR\n\nPrincipal Components Regression\nPrincipal components regression (PCR) can be performed using the pcr() function, which is part of the {pls} library. We now apply PCR to the Hitters data, in order to predict Salary. Again, we ensure that the missing values have been removed from the data.\n\nlibrary(pls) \n\nWarning: package 'pls' was built under R version 4.1.3\n\n\n\nAttaching package: 'pls'\n\n\nThe following object is masked from 'package:stats':\n\n    loadings\n\nset.seed(2)\npcr.fit <- pcr(Salary ~ ., data = Hitters, scale = TRUE, validation = \"CV\")\n\nThe syntax for the pcr() function is similar to that for lm(), with a few additional options. Setting scale = TRUE has the effect of standardizing each predictor, prior to generating the principal components, so that the scale on which each variable is measured will not have an eﬀect. Setting validation = \"CV\" causes pcr() to compute the ten-fold cross-validation error for each possible value of M, the number of principal components used. The resulting fit can be examined using summary().\n\nsummary(pcr.fit)\n\nData:   X dimension: 263 19 \n    Y dimension: 263 1\nFit method: svdpc\nNumber of components considered: 19\n\nVALIDATION: RMSEP\nCross-validated using 10 random segments.\n       (Intercept)  1 comps  2 comps  3 comps  4 comps  5 comps  6 comps\nCV             452    351.9    353.2    355.0    352.8    348.4    343.6\nadjCV          452    351.6    352.7    354.4    352.1    347.6    342.7\n       7 comps  8 comps  9 comps  10 comps  11 comps  12 comps  13 comps\nCV       345.5    347.7    349.6     351.4     352.1     353.5     358.2\nadjCV    344.7    346.7    348.5     350.1     350.7     352.0     356.5\n       14 comps  15 comps  16 comps  17 comps  18 comps  19 comps\nCV        349.7     349.4     339.9     341.6     339.2     339.6\nadjCV     348.0     347.7     338.2     339.7     337.2     337.6\n\nTRAINING: % variance explained\n        1 comps  2 comps  3 comps  4 comps  5 comps  6 comps  7 comps  8 comps\nX         38.31    60.16    70.84    79.03    84.29    88.63    92.26    94.96\nSalary    40.63    41.58    42.17    43.22    44.90    46.48    46.69    46.75\n        9 comps  10 comps  11 comps  12 comps  13 comps  14 comps  15 comps\nX         96.28     97.26     97.98     98.65     99.15     99.47     99.75\nSalary    46.86     47.76     47.82     47.85     48.10     50.40     50.55\n        16 comps  17 comps  18 comps  19 comps\nX          99.89     99.97     99.99    100.00\nSalary     53.01     53.85     54.61     54.61\n\n\nThe CV score is provided for each possible number of components, ranging from M = 0 onwards. Note that pcr() reports the root mean squared error ; in order to obtain the usual MSE, we must square this quantity. For instance, a root mean squared error of 352.8 corresponds to an MSE of 352.82 = 124,468.\nOne can also plot the cross-validation scores using the validationplot() function. Using val.type = \"MSEP\" will cause the cross-validation MSE to be plotted.\n\nvalidationplot(pcr.fit, val.type = \"MSEP\")\n\n\n\n\nWe see that the smallest cross-validation error occurs when M = 18 components are used. This is barely fewer than M = 19, which amounts to simply performing least squares, because when all of the components are used in PCR no dimension reduction occurs. However, from the plot we also see that the cross-validation error is roughly the same when only one component is included in the model. This suggests that a model that uses just a small number of components might suﬃce.\nThe summary() function also provides the percentage of variance explained in the predictors and in the response using diﬀerent numbers of components. Briefly, we can think of this as the amount of information about the predictors or the response that is captured using M principal components. For example, setting M = 1 only captures 38.31% of all the variance, or information, in the predictors. In contrast, using M = 5 increases the value to 84.29%. If we were to use all M = p = 19 components, this would increase to 100%.\nWe now perform PCR on the training data and evaluate its test set performance.\n\nset.seed(1)\npcr.fit <- pcr(Salary ~ ., data = Hitters, subset = train, \n               scale = TRUE, validation = \"CV\")\nvalidationplot(pcr.fit, val.type = \"MSEP\")\n\n\n\n\nNow we find that the lowest cross-validation error occurs when M = 5 components are used. We compute the test MSE as follows.\n\npcr.pred <- predict(pcr.fit, x[test, ], ncomp = 5)\nmean((pcr.pred - y.test )^2)\n\n[1] 142811.8\n\n\nThis test set MSE is competitive with the results obtained using ridge regression and the lasso. However, as a result of the way PCR is implemented, the final model is more difficult to interpret because it does not perform any kind of variable selection or even directly produce coeﬃcient estimates.\nFinally, we fit PCR on the full data set, using M = 5, the number of components identified by cross-validation.\n\npcr.fit <- pcr(y ~ x, scale = TRUE, ncomp = 5)\nsummary(pcr.fit)\n\nData:   X dimension: 263 19 \n    Y dimension: 263 1\nFit method: svdpc\nNumber of components considered: 5\nTRAINING: % variance explained\n   1 comps  2 comps  3 comps  4 comps  5 comps\nX    38.31    60.16    70.84    79.03    84.29\ny    40.63    41.58    42.17    43.22    44.90"
  },
  {
    "objectID": "lab06-mod-selection.html#pls",
    "href": "lab06-mod-selection.html#pls",
    "title": "Lab 06 Model selection",
    "section": "7 PLS",
    "text": "7 PLS\n\nPartial Least Squares\nWe implement partial least squares (PLS) using the plsr() function, also in the {pls} library. The syntax is just like that of the pcr() function.\n\n\nplsr()\n\nset.seed(1)\npls.fit <- plsr(Salary ~ ., data = Hitters, subset = train, \n                scale = TRUE , validation = \"CV\")\nsummary(pls.fit)\n\nData:   X dimension: 131 19 \n    Y dimension: 131 1\nFit method: kernelpls\nNumber of components considered: 19\n\nVALIDATION: RMSEP\nCross-validated using 10 random segments.\n       (Intercept)  1 comps  2 comps  3 comps  4 comps  5 comps  6 comps\nCV           428.3    325.5    329.9    328.8    339.0    338.9    340.1\nadjCV        428.3    325.0    328.2    327.2    336.6    336.1    336.6\n       7 comps  8 comps  9 comps  10 comps  11 comps  12 comps  13 comps\nCV       339.0    347.1    346.4     343.4     341.5     345.4     356.4\nadjCV    336.2    343.4    342.8     340.2     338.3     341.8     351.1\n       14 comps  15 comps  16 comps  17 comps  18 comps  19 comps\nCV        348.4     349.1     350.0     344.2     344.5     345.0\nadjCV     344.2     345.0     345.9     340.4     340.6     341.1\n\nTRAINING: % variance explained\n        1 comps  2 comps  3 comps  4 comps  5 comps  6 comps  7 comps  8 comps\nX         39.13    48.80    60.09    75.07    78.58    81.12    88.21    90.71\nSalary    46.36    50.72    52.23    53.03    54.07    54.77    55.05    55.66\n        9 comps  10 comps  11 comps  12 comps  13 comps  14 comps  15 comps\nX         93.17     96.05     97.08     97.61     97.97     98.70     99.12\nSalary    55.95     56.12     56.47     56.68     57.37     57.76     58.08\n        16 comps  17 comps  18 comps  19 comps\nX          99.61     99.70     99.95    100.00\nSalary     58.17     58.49     58.56     58.62\n\nvalidationplot(pls.fit, val.type = \"MSEP\")\n\n\n\n\nThe lowest cross-validation error occurs when only M = 1 partial least squares directions are used. We now evaluate the corresponding test set MSE.\n\npls.pred <- predict(pls.fit, x[test, ], ncomp = 1)\nmean((pls.pred - y.test)^2)\n\n[1] 151995.3\n\n\nThe test MSE is comparable to, but slightly higher than, the test MSE obtained using ridge regression, the lasso, and PCR.\nFinally, we perform PLS using the full data set, using M = 1, the number of components identified by cross-validation.\n\npls.fit <- plsr(Salary ~ ., data = Hitters, scale = TRUE, ncomp = 1)\nsummary (pls.fit)\n\nData:   X dimension: 263 19 \n    Y dimension: 263 1\nFit method: kernelpls\nNumber of components considered: 1\nTRAINING: % variance explained\n        1 comps\nX         38.08\nSalary    43.05\n\n\nNotice that the percentage of variance in Salary that the one-component PLS fit explains, 43.05%, is almost as much as that explained using the final five-component model PCR fit, 44.90%. This is because PCR only attempts to maximize the amount of variance explained in the predictors, while PLS searches for directions that explain variance in both the predictors and the response."
  },
  {
    "objectID": "lab07-non-linear.html",
    "href": "lab07-non-linear.html",
    "title": "Lab 07 Non-linear models",
    "section": "",
    "text": "In this lab, we will analyze the Wage data set in the {ISLR2} package, in order to illustrate non-linear fitting procedures in R.\n\nlibrary(ISLR2)\nattach(Wage) \n\n\n\nWe now examine how a non-linear model can be produced. We first fit the model using the following command\n\nfit <- lm(wage ~ poly(age, 4), data = Wage )\ncoef(summary(fit))\n\n                Estimate Std. Error    t value     Pr(>|t|)\n(Intercept)    111.70361  0.7287409 153.283015 0.000000e+00\npoly(age, 4)1  447.06785 39.9147851  11.200558 1.484604e-28\npoly(age, 4)2 -478.31581 39.9147851 -11.983424 2.355831e-32\npoly(age, 4)3  125.52169 39.9147851   3.144742 1.678622e-03\npoly(age, 4)4  -77.91118 39.9147851  -1.951938 5.103865e-02\n\n\nThis syntax fits a linear model, using the lm() function, in order to predict wage using a fourth-degree polynomial in age: poly(age, 4). The poly() command allows us to avoid having to write out a long formula with powers of age. The function returns a matrix whose columns are a basis of orthogonal polynomials, which essentially means that each column is a linear combination of the variables age, age^2, age^3 and age^4.\nHowever, we can also use poly() to obtain age, age^2, age^3 and age^4 directly, if we prefer. We can do this by using the raw = TRUE argument to the poly() function. Later we see that while this does not affect the model in a meaningful way, it affects the coefficient estimates, but it does not affect the fitted values obtained.\n\nfit2 <- lm(wage ~ poly (age, 4, raw = T), data = Wage)\ncoef(summary(fit2))\n\n                            Estimate   Std. Error   t value     Pr(>|t|)\n(Intercept)            -1.841542e+02 6.004038e+01 -3.067172 0.0021802539\npoly(age, 4, raw = T)1  2.124552e+01 5.886748e+00  3.609042 0.0003123618\npoly(age, 4, raw = T)2 -5.638593e-01 2.061083e-01 -2.735743 0.0062606446\npoly(age, 4, raw = T)3  6.810688e-03 3.065931e-03  2.221409 0.0263977518\npoly(age, 4, raw = T)4 -3.203830e-05 1.641359e-05 -1.951938 0.0510386498\n\n\nThere are several other equivalent ways of fitting this model, which showcase the flexibility of the formula language in R. For example\n\n\n\n\nfit2a <- lm(wage ~ age + I(age^2) + I(age^3) + I(age^4), data = Wage )\ncoef(fit2a)\n\n  (Intercept)           age      I(age^2)      I(age^3)      I(age^4) \n-1.841542e+02  2.124552e+01 -5.638593e-01  6.810688e-03 -3.203830e-05 \n\n\nThis simply creates the polynomial basis functions on the fly, taking care to protect terms like age^2 via the wrapper function I() (remember the ^ symbol has a special meaning in formulas).\n\n\n\n\nfit2b <- lm(wage ~ cbind(age, age^2 , age^3 , age^4), data = Wage )\n\nThis does the same more compactly, using the cbind() function for building a matrix from a collection of vectors; any function call such as cbind() inside a formula also serves as a wrapper.\nWe now create a grid of values for age at which we want predictions, and then call the generic predict() function, specifying that we want standard errors as well.\n\nattach(Wage)\n\nThe following objects are masked from Wage (pos = 3):\n\n    age, education, health, health_ins, jobclass, logwage, maritl,\n    race, region, wage, year\n\nagelims <- range(age) \nage.grid <- seq(from = agelims[1] , to = agelims[2])\npreds <- predict(fit, newdata = list(age = age.grid ), se = TRUE)\n\n# make confidence intervals\nse.bands <- cbind (preds$fit + 2 * preds$se.fit , preds$fit - 2 * preds$se.fit)\n\nFinally, we plot the data and add the fit from the degree-4 polynomial.\n\npar(mfrow = c(1, 1) , mar = c(4.5, 4.5, 1, 1),\n    oma = c(0, 0, 4, 0))\n\n# we'll make the right hand plot below...\nplot(age, wage, xlim = agelims, cex = .5, col = \"darkgrey\")\n\ntitle(\"Degree-4 Polynomial\", outer = T)\nlines(age.grid, preds$fit, lwd = 2, col = \"blue\")\nmatlines(age.grid, se.bands, lwd = 1, col = \"blue\", lty = 3)\n\n\n\n\nHere the mar and oma arguments to par() allow us to control the margins of the plot, and the title() function creates a figure title that spans both subplots. We mentioned earlier that whether or not an orthogonal set of basis functions is produced in the poly() function will not aﬀect the model obtained in a meaningful way. What do we mean by this? The fitted values obtained in either case are identical:\n\npreds2 <- predict(fit2, newdata = list(age = age.grid ), se = TRUE )\nmax( abs(preds$fit - preds2$fit))\n\n[1] 7.81597e-11\n\n\n\n\n\nIn performing a polynomial regression we must decide on the degree of the polynomial to use. One way to do this is by using hypothesis tests. We now fit models ranging from linear to a degree-5 polynomial and seek to determine the simplest model which is sufficient to explain the relationship between wage and age. We use the anova() function, which performs an analysis of variance (ANOVA, using an F-test) in order to test the null hypothesis that a model M1 is suﬃcient to explain the data against the alternative hypothesis that a more complex model M2 is required. In order to use the anova() function, M1 and M2 must be nested models: the predictors in M1 must be a subset of the predictors in M2. In this case, we fit five different models and sequentially compare the simpler model to the more complex model.\n\nfit.1   <-  lm(wage ~   age, data   = Wage )    \nfit.2   <-  lm(wage ~   poly(age,   2), data    =   Wage )\nfit.3   <-  lm(wage ~   poly(age, 3),   data    =   Wage )\nfit.4   <-  lm(wage ~   poly(age, 4),   data    =   Wage )\nfit.5   <-  lm(wage ~   poly(age,   5), data    =   Wage )\n\n# Pr - p-val are mopdels different?\n# RSS lower unexplained error is better\nanova(fit.1, fit.2, fit.3, fit.4, fit.5)\n\nAnalysis of Variance Table\n\nModel 1: wage ~ age\nModel 2: wage ~ poly(age, 2)\nModel 3: wage ~ poly(age, 3)\nModel 4: wage ~ poly(age, 4)\nModel 5: wage ~ poly(age, 5)\n  Res.Df     RSS Df Sum of Sq        F    Pr(>F)    \n1   2998 5022216                                    \n2   2997 4793430  1    228786 143.5931 < 2.2e-16 ***\n3   2996 4777674  1     15756   9.8888  0.001679 ** \n4   2995 4771604  1      6070   3.8098  0.051046 .  \n5   2994 4770322  1      1283   0.8050  0.369682    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nThe p-value comparing the linear Model 1 to the quadratic Model 2 is essentially zero (<10−15), indicating that a linear fit is not suﬃcient. Similarly the p-value comparing the quadratic Model 2 to the cubic Model 3 is very low (0.0017), so the quadratic fit is also insufficient. The p-value comparing the cubic and degree-4 polynomials, Model 3 and Model 4, is approximately 5% while the degree-5 polynomial Model 5 seems unnecessary because its p-value is 0.37. Hence, either a cubic or a quartic polynomial appear to provide a reasonable fit to the data, but lower- or higher-order models are not justified.\n\n\n\nIn this case, instead of using the anova() function, we could have obtained these p-values more succinctly by exploiting the fact that poly() creates orthogonal polynomials.\n\ncoef(summary(fit.5))\n\n                Estimate Std. Error     t value     Pr(>|t|)\n(Intercept)    111.70361  0.7287647 153.2780243 0.000000e+00\npoly(age, 5)1  447.06785 39.9160847  11.2001930 1.491111e-28\npoly(age, 5)2 -478.31581 39.9160847 -11.9830341 2.367734e-32\npoly(age, 5)3  125.52169 39.9160847   3.1446392 1.679213e-03\npoly(age, 5)4  -77.91118 39.9160847  -1.9518743 5.104623e-02\npoly(age, 5)5  -35.81289 39.9160847  -0.8972045 3.696820e-01\n\n\nNotice that the p-values are the same, and in fact the square of the t-statistics are equal to the F-statistics from the anova() function; for example:\n\n(-11.983)^2\n\n[1] 143.5923\n\n\nHowever, the ANOVA method works whether or not we used orthogonal polynomials; it also works when we have other terms in the model as well. For example, we can use anova() to compare these three models:\n\nfit.1 <- lm(wage ~ education + age , data = Wage )\nfit.2 <- lm(wage ~ education + poly(age, 2), data = Wage )\nfit.3 <- lm(wage ~ education + poly(age, 3), data = Wage )\nanova(fit.1 , fit.2 , fit.3)\n\nAnalysis of Variance Table\n\nModel 1: wage ~ education + age\nModel 2: wage ~ education + poly(age, 2)\nModel 3: wage ~ education + poly(age, 3)\n  Res.Df     RSS Df Sum of Sq        F Pr(>F)    \n1   2994 3867992                                 \n2   2993 3725395  1    142597 114.6969 <2e-16 ***\n3   2992 3719809  1      5587   4.4936 0.0341 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAs an alternative to using hypothesis tests and ANOVA, we could choose the polynomial degree using cross-validation.\n\n\n\nNext we consider the task of predicting whether an individual earns more than $250,000 per year. We proceed much as before, except that first we create the appropriate response vector, and then apply the glm() function using family = \"binomial\" in order to fit a polynomial logistic regression model.\n\nfit <- glm(I(wage > 250) ~ poly(age, 4) , data = Wage , family = binomial )\n\nNote that we again use the wrapper I() to create this binary response variable on the fly. The expression wage > 250 evaluates to a logical variable containing TRUEs and FALSEs, which glm() coerces to binary by setting the TRUEs to 1 and the FALSEs to 0.\n\n\n\nOnce again, we make predictions using the predict() function.\n\npreds <- predict(fit, newdata = list(age = age.grid ), se = T)\n\nHowever, calculating the confidence intervals is slightly more involved than in the linear regression case. The default prediction type for a glm() model is type = \"link\", which is what we use here. This means we get predictions for the logit, or log-odds: that is, we have fit a model of the form:\n\\(log\\frac{Pr(Y = 1|X) }{1 − Pr(Y = 1|X)} = X\\beta\\)\nand the predictions given are of the form \\(X\\hat\\beta\\). The standard errors given are also for \\(X\\hat\\beta\\). In order to obtain confidence intervals for \\(Pr(Y = 1 X)\\), we use the transformation\n\\(Pr(Y = 1|X)=\\frac{exp(X\\beta)}{1 + exp(X\\beta)}\\)\n\npfit <- exp (preds $ fit ) / (1 + exp (preds $ fit ))\nse.bands.logit <- cbind(preds$fit + 2 * preds$se.fit, preds$fit - 2 * preds$se.fit)\nse.bands <- exp(se.bands.logit) / (1 + exp(se.bands.logit))\n\nNote that we could have directly computed the probabilities by selecting the type = \"response\" option in the predict() function.\n\npreds <- predict(fit, newdata = list(age = age.grid ), type = \"response\", se = T)\n\nHowever, the corresponding confidence intervals would not have been sensible because we would end up with negative probabilities!\n\n\n\n\nplot(age , I(wage > 250), xlim = agelims, type = \"n\", ylim = c(0, .2) )\npoints(jitter (age), I((wage > 250) / 5), cex = .5, pch = \"|\", col = \"darkgrey \")\nlines (age.grid, pfit, lwd = 2, col = \"blue \")\nmatlines(age.grid, se.bands, lwd = 1 , col = \"blue \", lty = 3)\n\n\n\npar(mfrow=c(1,1))\n\n\n\n\nWe have drawn the age values corresponding to the observations with wage values above 250 as gray marks on the top of the plot, and those with wage values below 250 are shown as gray marks on the bottom of the plot. We used the jitter() function to jitter the age values a bit so that observations with the same age value do not cover each other up. This is often called a rug plot.\n\n\n\nIn order to fit a step function, we use the cut() function.\n\ntable(cut (age, 4))\n\n\n(17.9,33.5]   (33.5,49]   (49,64.5] (64.5,80.1] \n        750        1399         779          72 \n\nfit <- lm(wage ~ cut (age, 4), data = Wage )\ncoef(summary(fit))\n\n                        Estimate Std. Error   t value     Pr(>|t|)\n(Intercept)            94.158392   1.476069 63.789970 0.000000e+00\ncut(age, 4)(33.5,49]   24.053491   1.829431 13.148074 1.982315e-38\ncut(age, 4)(49,64.5]   23.664559   2.067958 11.443444 1.040750e-29\ncut(age, 4)(64.5,80.1]  7.640592   4.987424  1.531972 1.256350e-01\n\n\nHere cut() automatically picked the cutpoints at 33.5, 49, and 64.5 years of age. We could also have specified our own cutpoints directly using the breaks option. The function cut() returns an ordered categorical variable; the lm() function then creates a set of dummy variables for use in the re- gression. The age < 33.5 category is left out, so the intercept coefficient of $94,160 can be interpreted as the average salary for those under 33.5 years of age, and the other coeﬃcients can be interpreted as the average additional salary for those in the other age groups. We can produce predictions and plots just as we did in the case of the polynomial fit.\n\n\n\nIn order to fit regression splines in R, we use the {splines} library. Regression splines can be fit by constructing an appropriate matrix of basis functions. The bs() function generates the entire matrix of basis functions for splines with the specified set of knots. By default, cubic splines are produced. (see ch 7 James et al 2021)\n\n\n\nFitting wage to age using a regression spline is simple:\n\nlibrary(splines) \nfit <- lm(wage ~ bs(age, knots = c(25, 40, 60)), data = Wage )\npred <- predict(fit , newdata = list(age = age.grid), se = T)\nplot(age, wage, col = \"gray\")\nlines(age.grid, pred$fit , lwd = 2)\nlines(age.grid, pred$fit + 2 * pred$se, lty = \"dashed\", col = 'blue')\nlines(age.grid, pred$fit - 2 * pred$se, lty = \"dashed\", col = 'blue')\n\n\n\n\n\n\n\nHere we have prespecified knots at ages 25, 40, and 60. This produces a spline with six basis functions. (Recall that a cubic spline with three knots has seven degrees of freedom; these degrees of freedom are used up by an intercept, plus six basis functions.) We could also use the df option to produce a spline with knots at uniform quantiles of the data.\n\ndim(bs(age, knots = c(25 , 40 , 60) ))\n\n[1] 3000    6\n\ndim(bs(age, df = 6))\n\n[1] 3000    6\n\nattr(bs(age, df = 6), \"knots\") \n\n  25%   50%   75% \n33.75 42.00 51.00 \n\n\nIn this case R chooses knots at ages 33.8, 42.0, and 51.0, which correspond to the 25th, 50th, and 75th percentiles of age. The function bs() also has a degree argument, so we can fit splines of any degree, rather than the default degree of 3 (which yields a cubic spline).\n\n\n\nIn order to instead fit a natural spline, we use the ns() function. Here we fit a natural spline with four degrees of freedom.\n\nfit2 <- lm(wage ~ ns(age, df = 4), data = Wage)\npred2 <- predict(fit2, newdata = list(age = age.grid ), se = T)\n\nplot(age, wage, col = \"gray\")\nlines(age.grid, pred$fit , lwd = 2)\nlines(age.grid, pred$fit + 2 * pred$se, lty = \"dashed\", col = 'blue')\nlines(age.grid, pred$fit - 2 * pred$se, lty = \"dashed\", col = 'blue')\nlines(age.grid, pred2$fit, col = \"red\", lwd = 2)\n\n\n\n\nAs with the bs() function, we could instead specify the knots directly using the knots option.\n\n\n\nIn order to fit a smoothing spline, we use the smooth.spline() function.\n\nplot(age, wage, xlim = agelims, cex = .5, col = \"darkgrey\")\ntitle(\"Smoothing Spline\")\nfit <- smooth.spline(age, wage, df = 16)\nfit2 <- smooth.spline(age, wage, cv = TRUE )\n\nWarning in smooth.spline(age, wage, cv = TRUE): cross-validation with non-unique\n'x' values seems doubtful\n\nfit2$df\n\n[1] 6.794596\n\nlines(fit, col = \"red\", lwd = 2)\nlines(fit2, col = \"blue\", lwd = 2)\nlegend (\"topright\", \n        legend = c(\"16 DF\", \"6.8 DF\"), \n        col = c(\"red\", \"blue\"), \n        lty = 1 , lwd = 2 , cex = .8)\n\n\n\n\nNotice that in the first call to smooth.spline(), we specified df = 16. The function then determines which value of \\(\\lambda\\) leads to 16 degrees of freedom. In the second call to smooth.spline(), we select the smoothness level by cross-validation; this results in a value of \\(\\lambda\\) that yields 6.8 degrees of freedom.\n\n\n\nIn order to perform local regression, we use the loess() function.\n\nplot(age, wage , xlim = agelims, cex = .5 , col = \"darkgrey\")\ntitle(\"Local Regression\")\nfit <- loess(wage ~ age , span = .2, data = Wage )\nfit2 <- loess (wage ~ age , span = .5, data = Wage )\nfit3 <- loess (wage ~ age , span = .8, data = Wage )\n\nlines(age.grid , predict(fit, data.frame (age = age.grid )),\n      col = \"red\", lwd = 2)\nlines (age.grid , predict(fit2, data.frame (age = age.grid )), \n       col = \"blue\", lwd = 2)\nlines (age.grid , predict(fit3, data.frame (age = age.grid )), \n       col = \"goldenrod\", lwd = 2)\n\nlegend(\"topright\", legend = c(\"Span = 0.2\", \"Span = 0.5\", \"Span = 0.8\"), \n       col = c(\"red\", \"blue\", \"goldenrod\"), lty = 1, lwd = 2, cex = .8)\n\n\n\n\nHere we have performed local linear regression using different spans: that is, each neighborhood consists of 20%, 50% or 80% of the observations. The larger the span, the smoother the fit. The {locfit} library can also be used for fitting local regression models in R."
  },
  {
    "objectID": "lab07-non-linear.html#exercises",
    "href": "lab07-non-linear.html#exercises",
    "title": "Lab 07 Non-linear models",
    "section": "3 Exercises",
    "text": "3 Exercises\n\nExercise 1\n\n1.1\nIn this exercise, you will further analyze the Wage data set considered throughout this lab.\nPerform polynomial regression to predict wage using age. Use cross-validation to select the optimal degree d for the polynomial. What degree was chosen, and how does this compare to the results of hypothesis testing using ANOVA? Make a plot of the resulting polynomial fit to the data.\n\n\n1.2\nFit a step function to predict wage using age, and perform crossvalidation to choose the optimal number of cuts. Make a plot of the fit obtained.\n\n\n\nExercise 2\nThe Wage data set contains a number of other features not explored in this chapter, such as marital status (maritl), job class (jobclass), and others. Explore the relationships between some of these other predictors and wage, and use non-linear fitting techniques in order to fit flexible models to the data. Create plots of the results obtained, and write a summary of your findings.\n\n\nExercise 3\nFit some of the non-linear models investigated in this lab to the Auto data set. Is there evidence for non-linear relationships in this data set? Create some informative plots to justify your answer."
  },
  {
    "objectID": "lab07-non-linear.html#resources",
    "href": "lab07-non-linear.html#resources",
    "title": "Lab 07 Non-linear models",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "lab07-non-linear.html#harper-adams-data-science",
    "href": "lab07-non-linear.html#harper-adams-data-science",
    "title": "Lab 07 Non-linear models",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab07-non-linear.html#gams",
    "href": "lab07-non-linear.html#gams",
    "title": "Lab 07 Non-linear models",
    "section": "2 GAMs",
    "text": "2 GAMs\nGAMs are non-linear Generalised Additive Models.\nWe now fit a GAM to predict wage using natural spline functions of year and age, treating education as a qualitative predictor. Since this is just a big linear regression model using an appropriate choice of basis functions, we can simply do this using the lm() function.\n\n# lm() with natural splines for fit\ngam1 <- lm(wage ~ ns(year , 4) + ns(age , 5) + education ,\n           data = Wage)\n\nWe now fit a model using smoothing splines rather than natural splines. In order to fit more general sorts of GAMs, using smoothing splines or other components that cannot be expressed in terms of basis functions and then fit using least squares regression, we will need to use the {gam} library in R.\n\ns() smooooth spline\nThe s() function, which is part of the {gam} library, is used to indicate that we would like to use a smoothing spline. We specify that the function of year should have 4 degrees of freedom, and that the function of age will have 5 degrees of freedom. Since education is qualitative, we leave it as is, and it is converted into four dummy variables. We use the gam() function in order to fit a GAM using these components. All model terms are fit simultaneously, taking each other into account to explain the response.\n\nlibrary (gam) \n\nLoading required package: foreach\n\n\nLoaded gam 1.20.2\n\ngam.m3 <- gam (wage ~ s(year, 4) + s(age , 5) + education , data = Wage )\n\npar(mfrow = c(1, 3)) \nplot(gam.m3, se = TRUE, col = \"blue\")\n\n\n\n\nThe generic plot() function recognizes that gam.m3 is an object of class Gam, and invokes the appropriateplot.Gam() method. Conveniently, even though gam1 is not of class Gam but rather of class lm, we can still use plot.Gam() on it.\n\n\nplot.GAM()\n\npar(mfrow=c(1,3))\nplot.Gam(gam1, se = TRUE, col = \"red\")\n\n\n\n\nNotice here the use of plot.Gam() rather than the generic plot() function.\nIn these plots, the function of year looks rather linear. We can perform a series of ANOVA tests in order to determine which model is best: a GAM that excludes year (M1), a GAM that uses a linear function of year (M2), or a GAM that uses a spline function of year (M3).\n\ngam.m1 <- gam (wage ~ s(age , 5) + education, data = Wage )\ngam.m2 <- gam (wage ~ year + s(age, 5) + education, data = Wage )\n\nanova (gam.m1, gam.m2, gam.m3, test = \"F\") \n\nAnalysis of Deviance Table\n\nModel 1: wage ~ s(age, 5) + education\nModel 2: wage ~ year + s(age, 5) + education\nModel 3: wage ~ s(year, 4) + s(age, 5) + education\n  Resid. Df Resid. Dev Df Deviance       F    Pr(>F)    \n1      2990    3711731                                  \n2      2989    3693842  1  17889.2 14.4771 0.0001447 ***\n3      2986    3689770  3   4071.1  1.0982 0.3485661    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nWe find that there is compelling evidence that a GAM with a linear function of year is better than a GAM that does not include year at all (p-value = 0.00014). However, there is no evidence that a non-linear function of year is needed (p-value = 0.349). In other words, based on the results of this ANOVA, M2 is preferred.\nThe summary() function produces a summary of the gam fit.\n\nsummary(gam.m3)\n\n\nCall: gam(formula = wage ~ s(year, 4) + s(age, 5) + education, data = Wage)\nDeviance Residuals:\n    Min      1Q  Median      3Q     Max \n-119.43  -19.70   -3.33   14.17  213.48 \n\n(Dispersion Parameter for gaussian family taken to be 1235.69)\n\n    Null Deviance: 5222086 on 2999 degrees of freedom\nResidual Deviance: 3689770 on 2986 degrees of freedom\nAIC: 29887.75 \n\nNumber of Local Scoring Iterations: NA \n\nAnova for Parametric Effects\n             Df  Sum Sq Mean Sq F value    Pr(>F)    \ns(year, 4)    1   27162   27162  21.981 2.877e-06 ***\ns(age, 5)     1  195338  195338 158.081 < 2.2e-16 ***\neducation     4 1069726  267432 216.423 < 2.2e-16 ***\nResiduals  2986 3689770    1236                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nAnova for Nonparametric Effects\n            Npar Df Npar F  Pr(F)    \n(Intercept)                          \ns(year, 4)        3  1.086 0.3537    \ns(age, 5)         4 32.380 <2e-16 ***\neducation                            \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nThe “Anova for Parametric Effects” p-values clearly demonstrate that year, age, and education are all highly statistically significant, even when only assuming a linear relationship. Alternatively, the “Anova for Nonparamet- ric Eﬀects” p-values for year and age correspond to a null hypothesis of a linear relationship versus the alternative of a non-linear relationship. The large p-value for year reinforces our conclusion from the ANOVA test that a linear function is adequate for this term. However, there is very clear evidence that a non-linear term is required for age.\n\n\npredict() GAM\nWe can make predictions using the predict() method for the class Gam. Here we make predictions on the training set.\n\npreds <- predict(gam.m2, newdata = Wage)\n\n\n\nlo()\nWe can also use local regression fits as building blocks in a GAM, using the lo() function.\n\ngam.lo <- gam(\n  wage ~ s(year, df = 4) + lo(age, span = 0.7) + education, data = Wage\n  )\npar(mfrow=c(1,3))\nplot.Gam(gam.lo, se = TRUE, col = \"green\")\n\n\n\n\nHere we have used local regression for the age term, with a span of 0.7. We can also use the lo() function to create interactions before calling the gam() function. For example,\n\ngam.lo.i <- gam(wage ~ lo(year, age, span = 0.5) + education,\n                data = Wage )\n\nfits a two-term model, in which the first term is an interaction between year and age, fit by a local regression surface. We can plot the resulting two-dimensional surface if we first install the {akima} and {interp} packages.\n\nlibrary(akima)\n\nWarning: package 'akima' was built under R version 4.1.3\n\nlibrary(interp)\n\nWarning: package 'interp' was built under R version 4.1.3\n\n\n\nAttaching package: 'interp'\n\n\nThe following objects are masked from 'package:akima':\n\n    aspline, bicubic, bicubic.grid, bilinear, bilinear.grid,\n    franke.data, franke.fn, interp, interp2xyz, interpp\n\npar(mfrow=c(1,2))\nplot(gam.lo.i)\n\n\n\n\nIn order to fit a logistic regression GAM, we once again use the I() function in constructing the binary response variable, and set family=binomial.\n\ngam.lr <- gam(I(wage > 250) ~ year + s(age, df = 5) + education,\n              family = binomial, \n              data = Wage)\n\npar(mfrow = c(1 , 3))\n# ok but tricky to interpret\nplot(gam.lr, se = T, col = \"green\")\n\n\n\n\nIt is easy to see that there are no high earners in the < HS Grad (less than high school, roughly equivalent to school leavers in the UK) category:\n\ntable(education, I(wage>250))\n\n                    \neducation            FALSE TRUE\n  1. < HS Grad         268    0\n  2. HS Grad           966    5\n  3. Some College      643    7\n  4. College Grad      663   22\n  5. Advanced Degree   381   45\n\n\nHence, we fit a logistic regression GAM using all but this category. This provides more sensible results.\n\ngam.lr.s <- gam(I(wage > 250) ~ year + s(age, df = 5) + education, \n                family = binomial, data = Wage,\n                subset = (education != \"1. < HS Grad\"))\npar(mfrow=c(1,3))\nplot(gam.lr.s, se = T, col = \"green\")"
  },
  {
    "objectID": "lab08-trees.html",
    "href": "lab08-trees.html",
    "title": "Lab 08 Decision trees",
    "section": "",
    "text": "The {tree} library is used to construct classification and regression trees.\n\n\nWe first use classification trees to analyze the Carseats data set. In these data, Sales is a continuous variable, and so we begin by recoding it as a binary variable. We use the ifelse() function to create a variable, called High, which takes on a value of Yes if the Sales variable exceeds 8, and takes on a value of No otherwise.\n\nlibrary(tree)\nlibrary(ISLR2)\nattach(Carseats)\nHigh <- factor(ifelse(Sales <= 8 , \"No\", \"Yes\")) \n\nFinally, we use the data.frame() function to merge High with the rest of the Carseats data.\n\nCarseats <- data.frame(Carseats, High )\n\nWe now use the tree() function to fit a classification tree in order to predict High using all variables but Sales. The syntax of the tree() function is quite similar to that of the lm() function.\nThe summary() function lists the variables that are used as internal nodes in the tree, the number of terminal nodes, and the (training) error rate.\n\ntree.carseats <- tree(High ~ . -Sales, Carseats)\nsummary(tree.carseats)\n\n\nClassification tree:\ntree(formula = High ~ . - Sales, data = Carseats)\nVariables actually used in tree construction:\n[1] \"ShelveLoc\"   \"Price\"       \"Income\"      \"CompPrice\"   \"Population\" \n[6] \"Advertising\" \"Age\"         \"US\"         \nNumber of terminal nodes:  27 \nResidual mean deviance:  0.4575 = 170.7 / 373 \nMisclassification error rate: 0.09 = 36 / 400 \n\n\nWe see that the training error rate is 9%. For classification trees, the deviance reported in the output of summary() is given by\n\\(-\\underset m \\sum \\underset k \\sum n_{mk} log \\hat p_{mk}\\)\nwhere \\(n_{mk}\\) is the number of observations in the \\(m\\)th terminal node that belong to the \\(k\\)th class. This is closely related to entropy (see James et al. 2021). A small deviance indicates a tree that provides a good fit to the (training) data. The residual mean deviance reported is simply the deviance divided by \\(n − |T_0|\\), which in this case is 400 − 27 = 373.\n\n\n\nOne of the most attractive properties of trees is that they can be graphically displayed. We use the plot() function to display the tree struc- ture, and the text() function to display the node labels. The argument pretty = 0 instructs R to include the category names for any qualitative predictors, rather than simply displaying a letter for each category.\n\npar(mfrow=c(1,1))\nplot(tree.carseats)\ntext(tree.carseats, pretty = 0, cex = .6)\n\n\n\n\nThe most important indicator of Sales appears to be shelving location, since the first branch differentiates Good locations from Bad and Medium locations.\nIf we just type the name of the tree object, R prints output corresponding to each branch of the tree. R displays the split criterion (e.g. Price < 92.5), the number of observations in that branch, the deviance, the overall prediction for the branch (Yes or No), and the fraction of observations in that branch that take on values of Yes and No. Branches that lead to terminal nodes are indicated using asterisks.\n\ntree.carseats\n\nnode), split, n, deviance, yval, (yprob)\n      * denotes terminal node\n\n  1) root 400 541.500 No ( 0.59000 0.41000 )  \n    2) ShelveLoc: Bad,Medium 315 390.600 No ( 0.68889 0.31111 )  \n      4) Price < 92.5 46  56.530 Yes ( 0.30435 0.69565 )  \n        8) Income < 57 10  12.220 No ( 0.70000 0.30000 )  \n         16) CompPrice < 110.5 5   0.000 No ( 1.00000 0.00000 ) *\n         17) CompPrice > 110.5 5   6.730 Yes ( 0.40000 0.60000 ) *\n        9) Income > 57 36  35.470 Yes ( 0.19444 0.80556 )  \n         18) Population < 207.5 16  21.170 Yes ( 0.37500 0.62500 ) *\n         19) Population > 207.5 20   7.941 Yes ( 0.05000 0.95000 ) *\n      5) Price > 92.5 269 299.800 No ( 0.75465 0.24535 )  \n       10) Advertising < 13.5 224 213.200 No ( 0.81696 0.18304 )  \n         20) CompPrice < 124.5 96  44.890 No ( 0.93750 0.06250 )  \n           40) Price < 106.5 38  33.150 No ( 0.84211 0.15789 )  \n             80) Population < 177 12  16.300 No ( 0.58333 0.41667 )  \n              160) Income < 60.5 6   0.000 No ( 1.00000 0.00000 ) *\n              161) Income > 60.5 6   5.407 Yes ( 0.16667 0.83333 ) *\n             81) Population > 177 26   8.477 No ( 0.96154 0.03846 ) *\n           41) Price > 106.5 58   0.000 No ( 1.00000 0.00000 ) *\n         21) CompPrice > 124.5 128 150.200 No ( 0.72656 0.27344 )  \n           42) Price < 122.5 51  70.680 Yes ( 0.49020 0.50980 )  \n             84) ShelveLoc: Bad 11   6.702 No ( 0.90909 0.09091 ) *\n             85) ShelveLoc: Medium 40  52.930 Yes ( 0.37500 0.62500 )  \n              170) Price < 109.5 16   7.481 Yes ( 0.06250 0.93750 ) *\n              171) Price > 109.5 24  32.600 No ( 0.58333 0.41667 )  \n                342) Age < 49.5 13  16.050 Yes ( 0.30769 0.69231 ) *\n                343) Age > 49.5 11   6.702 No ( 0.90909 0.09091 ) *\n           43) Price > 122.5 77  55.540 No ( 0.88312 0.11688 )  \n             86) CompPrice < 147.5 58  17.400 No ( 0.96552 0.03448 ) *\n             87) CompPrice > 147.5 19  25.010 No ( 0.63158 0.36842 )  \n              174) Price < 147 12  16.300 Yes ( 0.41667 0.58333 )  \n                348) CompPrice < 152.5 7   5.742 Yes ( 0.14286 0.85714 ) *\n                349) CompPrice > 152.5 5   5.004 No ( 0.80000 0.20000 ) *\n              175) Price > 147 7   0.000 No ( 1.00000 0.00000 ) *\n       11) Advertising > 13.5 45  61.830 Yes ( 0.44444 0.55556 )  \n         22) Age < 54.5 25  25.020 Yes ( 0.20000 0.80000 )  \n           44) CompPrice < 130.5 14  18.250 Yes ( 0.35714 0.64286 )  \n             88) Income < 100 9  12.370 No ( 0.55556 0.44444 ) *\n             89) Income > 100 5   0.000 Yes ( 0.00000 1.00000 ) *\n           45) CompPrice > 130.5 11   0.000 Yes ( 0.00000 1.00000 ) *\n         23) Age > 54.5 20  22.490 No ( 0.75000 0.25000 )  \n           46) CompPrice < 122.5 10   0.000 No ( 1.00000 0.00000 ) *\n           47) CompPrice > 122.5 10  13.860 No ( 0.50000 0.50000 )  \n             94) Price < 125 5   0.000 Yes ( 0.00000 1.00000 ) *\n             95) Price > 125 5   0.000 No ( 1.00000 0.00000 ) *\n    3) ShelveLoc: Good 85  90.330 Yes ( 0.22353 0.77647 )  \n      6) Price < 135 68  49.260 Yes ( 0.11765 0.88235 )  \n       12) US: No 17  22.070 Yes ( 0.35294 0.64706 )  \n         24) Price < 109 8   0.000 Yes ( 0.00000 1.00000 ) *\n         25) Price > 109 9  11.460 No ( 0.66667 0.33333 ) *\n       13) US: Yes 51  16.880 Yes ( 0.03922 0.96078 ) *\n      7) Price > 135 17  22.070 No ( 0.64706 0.35294 )  \n       14) Income < 46 6   0.000 No ( 1.00000 0.00000 ) *\n       15) Income > 46 11  15.160 Yes ( 0.45455 0.54545 ) *\n\n\nIn order to properly evaluate the performance of a classification tree on these data, we must estimate the test error rather than simply computing the training error. We split the observations into a training set and a test set, build the tree using the training set, and evaluate its performance on the test data. The predict() function can be used for this purpose. In the case of a classification tree, the argument type = \"class\" instructs R to return the actual class prediction. This approach leads to correct predictions for around 77% of the locations in the test data set.\n\nset.seed(2)\ntrain <- sample(1:nrow(Carseats), 200)\nCarseats.test <- Carseats[-train, ]\nHigh.test <- High[-train]\ntree.carseats <- tree(High ~ . -Sales, Carseats, subset = train)\ntree.pred <- predict(tree.carseats, Carseats.test, type = \"class\")\n\n# confusion matrix\ntable(tree.pred, High.test)\n\n         High.test\ntree.pred  No Yes\n      No  104  33\n      Yes  13  50\n\n# % correct\n(104 + 50) / 200\n\n[1] 0.77\n\n\n\n\n\n(If you re-run the predict() function then you might get slightly diﬀerent results, due to “ties”: for instance, this can happen when the training observations corresponding to a terminal node are evenly split between Yes and No response values.)\nNext, we consider whether pruning the tree might lead to improved results. The function cv.tree() performs cross-validation in order to determine the optimal level of tree complexity; cost complexity pruning is used in order to select a sequence of trees for consideration. We use the argument FUN = prune.misclass in order to indicate that we want the classification error rate to guide the cross-validation and pruning process, rather than the default for the cv.tree() function, which is deviance. The cv.tree() function reports the number of terminal nodes of each tree con- sidered (size) as well as the corresponding error rate and the value of the cost-complexity parameter used (k, which corresponds to \\(\\alpha\\) in (8.4)).\n\nset.seed(7)\ncv.carseats <- cv.tree(tree.carseats, FUN = prune.misclass )\nnames(cv.carseats )\n\n[1] \"size\"   \"dev\"    \"k\"      \"method\"\n\ncv.carseats\n\n$size\n[1] 21 19 14  9  8  5  3  2  1\n\n$dev\n[1] 75 75 75 74 82 83 83 85 82\n\n$k\n[1] -Inf  0.0  1.0  1.4  2.0  3.0  4.0  9.0 18.0\n\n$method\n[1] \"misclass\"\n\nattr(,\"class\")\n[1] \"prune\"         \"tree.sequence\"\n\n\nDespite its name, dev corresponds to the number of cross-validation errors. The tree with 9 terminal nodes results in only 74 cross-validation errors. We plot the error rate as a function of both size and k.\n\npar(mfrow = c(1, 2))\nplot(cv.carseats$size, cv.carseats$dev, type = \"b\",\n     pch=16, col = 'goldenrod')\nplot(cv.carseats$k, cv.carseats$dev, type = \"b\",\n     pch=16, col = 'goldenrod')\n\n\n\n\nWe now apply the prune.misclass() function in order to prune the tree to obtain the nine-node tree.\n\nprune.carseats <- prune.misclass(tree.carseats, best = 9)\npar(mfrow=c(1,1))\nplot(prune.carseats)\ntext(prune.carseats, pretty = 0)\n\n\n\n\nHow well does this pruned tree perform on the test data set? Once again, we apply the predict() function.\n\ntree.pred <- predict(prune.carseats, Carseats.test, type = \"class\")\ntable(tree.pred, High.test) \n\n         High.test\ntree.pred No Yes\n      No  97  25\n      Yes 20  58\n\n(97 + 58) / 200\n\n[1] 0.775\n\n\nNow 77.5% of the test observations are correctly classified, so not only has the pruning process produced a more interpretable tree, but it has also slightly improved the classification accuracy.\nIf we increase the value of best, we obtain a larger pruned tree with lower classification accuracy:\n\nprune.carseats <- prune.misclass(tree.carseats, best = 14)\nplot(prune.carseats)\ntext(prune.carseats, pretty = 0)\n\n\n\ntree.pred <- predict(prune.carseats, Carseats.test, type = \"class\")\n\ntable(tree.pred, High.test) \n\n         High.test\ntree.pred  No Yes\n      No  102  31\n      Yes  15  52\n\n(102 + 52) / 200\n\n[1] 0.77"
  },
  {
    "objectID": "lab08-trees.html#exercises",
    "href": "lab08-trees.html#exercises",
    "title": "Lab 08 Decision trees",
    "section": "6 Exercises",
    "text": "6 Exercises\n\nExercise 1\nIn this lab, we applied random forests to the Boston data using mtry = 6 and using ntree = 25 and ntree = 500. Create a plot displaying the test error resulting from random forests on this data set for a more comprehensive range of values for mtry and ntree. Describe the results obtained.\n\n\nExercise 2\nIn the lab, a classification tree was applied to the Carseats data set after converting Sales into a qualitative response variable. Now we will seek to predict Sales using regression trees and related approaches, treating the response as a quantitative variable.\n\n2.1\nSplit the data set into a training set and a test set.\n\n\n2.2\nFit a regression tree to the training set. Plot the tree, and interpret the results. What test MSE do you obtain?\n\n\n2.3\nUse cross-validation in order to determine the optimal level of tree complexity. Does pruning the tree improve the test MSE?\n\n\n2.4\nUse the bagging approach in order to analyze this data. What test MSE do you obtain? Use the importance() function to determine which variables are most important.\n\n\n2.5\nUse random forests to analyze this data. What test MSE do you obtain? Use the importance() function to determine which variables are most important. Describe the effect of m, the number of variables considered at each split, on the error rate obtained.\n\n\n2.6\nNow analyze the data using BART, and report your results."
  },
  {
    "objectID": "lab08-trees.html#resources",
    "href": "lab08-trees.html#resources",
    "title": "Lab 08 Decision trees",
    "section": "Resources",
    "text": "Resources"
  },
  {
    "objectID": "lab08-trees.html#harper-adams-data-science",
    "href": "lab08-trees.html#harper-adams-data-science",
    "title": "Lab 08 Decision trees",
    "section": "Harper Adams Data Science",
    "text": "Harper Adams Data Science\n\nThis module is a part of the MSc in Data Science for Global Agriculture, Food, and Environment at Harper Adams University, led by Ed Harris."
  },
  {
    "objectID": "lab08-trees.html#regression-trees",
    "href": "lab08-trees.html#regression-trees",
    "title": "Lab 08 Decision trees",
    "section": "2 Regression trees",
    "text": "2 Regression trees\nHere we fit a regression tree to the Boston data set. First, we create a training set, and fit the tree to the training data.\n\nset.seed(1)\ntrain <- sample(1:nrow(Boston), nrow(Boston) / 2)\ntree.boston <- tree(medv ~ ., Boston, subset = train )\nsummary(tree.boston ) \n\n\nRegression tree:\ntree(formula = medv ~ ., data = Boston, subset = train)\nVariables actually used in tree construction:\n[1] \"rm\"    \"lstat\" \"crim\"  \"age\"  \nNumber of terminal nodes:  7 \nResidual mean deviance:  10.38 = 2555 / 246 \nDistribution of residuals:\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-10.1800  -1.7770  -0.1775   0.0000   1.9230  16.5800 \n\n\nNotice that the output of summary() indicates that only four of the variables have been used in constructing the tree. In the context of a regression tree, the deviance is simply the sum of squared errors for the tree. We now plot the tree.\n\nplot(tree.boston)\ntext(tree.boston, pretty = 0)\n\n\n\n\nThe variable lstat measures the percentage of individuals with lower socioeconomic status, while the variable rm corresponds to the average number of rooms. The tree indicates that larger values of rm, or lower values of lstat, correspond to more expensive houses. For example, the tree predicts a median house price of $45,400 for homes in census tracts in which rm >= 7.553.\nIt is worth noting that we could have fit a much bigger tree, by pass- ing control = tree.control(nobs = length(train), mindev = 0) into the tree() function.\nNow we use the cv.tree() function to see whether pruning the tree will improve performance.\n\ncv.boston <- cv.tree(tree.boston)\nplot(cv.boston$size, cv.boston$dev, type = \"b\")\n\n\n\n\nIn this case, the most complex tree under consideration is selected by cross-validation. However, if we wish to prune the tree, we could do so as follows, using the prune.tree() function:\n\nprune.boston <- prune.tree(tree.boston, best = 5)\nplot(prune.boston)\ntext(prune.boston, pretty = 0)\n\n\n\n\nIn keeping with the cross-validation results, we use the unpruned tree to make predictions on the test set.\n\nyhat <- predict(tree.boston, newdata = Boston[-train, ])\nboston.test <- Boston[-train, \"medv\"]\nplot(yhat, boston.test )\nabline(0, 1)\n\n\n\nmean((yhat - boston.test )^2)\n\n[1] 35.28688\n\n\nIn other words, the test set MSE associated with the regression tree is 35.29. The square root of the MSE is therefore around 5.941, indicating that this model leads to test predictions that are (on average) within approximately $5,941 of the true median home value for the census tract."
  },
  {
    "objectID": "lab08-trees.html#bagging",
    "href": "lab08-trees.html#bagging",
    "title": "Lab 08 Decision trees",
    "section": "3 Bagging",
    "text": "3 Bagging\nHere we apply bagging and random forests to the Boston data, using the randomForest package in R. The exact results obtained in this section may depend on the version of R and the version of the {randomForest} package installed on your computer. Recall that bagging is simply a special case of a random forest with m = p. Therefore, the randomForest() function can be used to perform both random forests and bagging. We perform bagging as follows:\n\nlibrary(randomForest) \n\nrandomForest 4.6-14\n\n\nType rfNews() to see new features/changes/bug fixes.\n\nset.seed(1)\nbag.boston <- randomForest(medv ~ ., data = Boston,\n                           subset = train, mtry = 12, \n                           importance = TRUE)\nbag.boston \n\n\nCall:\n randomForest(formula = medv ~ ., data = Boston, mtry = 12, importance = TRUE,      subset = train) \n               Type of random forest: regression\n                     Number of trees: 500\nNo. of variables tried at each split: 12\n\n          Mean of squared residuals: 11.40162\n                    % Var explained: 85.17\n\n\nThe argument mtry = 12 indicates that all 12 predictors should be consid- ered for each split of the tree. In other words, that bagging should be done. How well does this bagged model perform on the test set?\n\nyhat.bag <- predict(bag.boston, newdata = Boston[-train, ])\nplot(yhat.bag, boston.test) \nabline(0, 1)\n\n\n\nmean((yhat.bag - boston.test )^2)\n\n[1] 23.41916\n\n\nThe test set MSE associated with the bagged regression tree is 23.42, about two-thirds of that obtained using an optimally-pruned single tree. We could change the number of trees grown by randomForest() using the ntree argument:\n\nbag.boston <- randomForest(medv ~ ., data = Boston,\n                           subset = train, mtry = 12, ntree = 25)\n\nyhat.bag <- predict(bag.boston, newdata = Boston[-train, ])\nmean((yhat.bag - boston.test )^2)\n\n[1] 25.75055\n\n\nGrowing a random forest proceeds in exactly the same way, except that we use a smaller value of the mtry argument. By default, randomForest() uses \\(p/3\\) variables when building a random forest of regression trees, and \\(\\sqrt p\\) variables when building a random forest of classification trees. Here we use mtry = 6.\n\nimportance()\n\nset.seed(1)\nrf.boston <- randomForest(medv ~ ., data = Boston, subset = train, \n                          mtry = 6, importance = TRUE )\n\nyhat.rf <- predict(rf.boston, newdata = Boston[-train, ])\nmean((yhat.rf - boston.test )^2)\n\n[1] 20.06644\n\n\nThe test set MSE is 20.07; this indicates that random forests yielded an improvement over bagging in this case.\nUsing the importance() function, we can view the importance of each variable.\n\nimportance(rf.boston)\n\n          %IncMSE IncNodePurity\ncrim    19.435587    1070.42307\nzn       3.091630      82.19257\nindus    6.140529     590.09536\nchas     1.370310      36.70356\nnox     13.263466     859.97091\nrm      35.094741    8270.33906\nage     15.144821     634.31220\ndis      9.163776     684.87953\nrad      4.793720      83.18719\ntax      4.410714     292.20949\nptratio  8.612780     902.20190\nlstat   28.725343    5813.04833\n\n\nTwo measures of variable importance are reported. The first is based upon the mean decrease of accuracy in predictions on the out of bag samples when a given variable is permuted. The second is a measure of the total decrease in node impurity that results from splits over that variable, averaged over all trees. In the case of regression trees, the node impurity is measured by the training RSS, and for classification trees by the deviance. Plots of these importance measures can be produced using the varImpPlot() function.\n\n\nvarImpPlot()\nThe results indicate that across all of the trees considered in the random forest, the wealth of the community (lstat) and the house size (rm) are by far the two most important variables.\n\nvarImpPlot(rf.boston)\n\n\n\n\nThe results indicate that across all of the trees considered in the random forest, the wealth of the community (lstat) and the house size (rm) are by far the two most important variables."
  },
  {
    "objectID": "lab08-trees.html#boosting",
    "href": "lab08-trees.html#boosting",
    "title": "Lab 08 Decision trees",
    "section": "4 Boosting",
    "text": "4 Boosting\n\ngbm()\nHere we use the gbm package, and within it the gbm() function, to fit boosted regression trees to the Boston data set. We run gbm() with the option distribution = \"gaussian\" since this is a regression problem; if it were a binary classification problem, we would use distribution = \"bernoulli\". The argument n.trees = 5000 indicates that we want 5000 trees, and the option interaction.depth = 4 limits the depth of each tree.\n\nlibrary(gbm) \n\nLoaded gbm 2.1.8\n\nset.seed(1)\nboost.boston <- gbm(medv ~ ., data = Boston[ train, ], \n                    distribution = \"gaussian\", n.trees = 5000,\n                    interaction.depth = 4)\n\nThe summary() function produces a relative influence plot and also outputs the relative influence statistics.\n\nsummary(boost.boston)\n\n\n\n\n            var     rel.inf\nrm           rm 44.48249588\nlstat     lstat 32.70281223\ncrim       crim  4.85109954\ndis         dis  4.48693083\nnox         nox  3.75222394\nage         age  3.19769210\nptratio ptratio  2.81354826\ntax         tax  1.54417603\nindus     indus  1.03384666\nrad         rad  0.87625748\nzn           zn  0.16220479\nchas       chas  0.09671228\n\n\n\n\nPartial dependence\nWe see that lstat and rm are by far the most important variables. We can also produce partial dependence plots for these two variables. These plots illustrate the marginal eﬀect of the selected variables on the response after integrating out the other variables. In this case, as we might expect, median house prices are increasing with rm and decreasing with lstat.\n\nplot(boost.boston, i = \"rm\")\n\n\n\nplot(boost.boston, i = \"lstat\")\n\n\n\n\nWe now use the boosted model to predict medv on the test set:\n\nyhat.boost <- predict(boost.boston,\n                      newdata = Boston[-train, ], \n                      n.trees = 5000)\n\nmean((yhat.boost - boston.test)^2)\n\n[1] 18.39057\n\n\nThe test MSE obtained is 18.39: this is superior to the test MSE of random forests and bagging. If we want to, we can perform boosting with a different value of the shrinkage parameter \\(\\lambda\\). The default value is 0.001, but this is easily modified. Here we take \\(\\lambda = 0.2\\).\n\nboost.boston <- gbm(medv ~ ., data = Boston[train, ],\n                    distribution = \"gaussian\", n.trees = 5000,\n                    interaction.depth = 4, shrinkage = 0.2, \n                    verbose = F)\n\nyhat.boost <- predict(boost.boston,\n                      newdata = Boston[-train, ], \n                      n.trees = 5000)\n\nmean((yhat.boost - boston.test)^2)\n\n[1] 16.54778\n\n\nIn this case, using \\(\\lambda = 0.2\\) leads to a lower test MSE than \\(\\lambda = 0.001\\)."
  },
  {
    "objectID": "lab08-trees.html#bayesian-additive-reg-trees",
    "href": "lab08-trees.html#bayesian-additive-reg-trees",
    "title": "Lab 08 Decision trees",
    "section": "5 Bayesian additive reg trees",
    "text": "5 Bayesian additive reg trees\n\n{BART} and gbart()\nIn this section we use the {BART} package, and within it the gbart() function, to fit a Bayesian additive regression tree model to the Boston housing data set. The gbart() function is designed for quantitative outcome variables. For binary outcomes, lbart() and pbart() are available.\nTo run the gbart() function, we must first create matrices of predictors for the training and test data. We run {BART} with default settings.\n\nlibrary(BART) \n\nWarning: package 'BART' was built under R version 4.1.3\n\n\nLoading required package: nlme\n\n\nLoading required package: nnet\n\n\nLoading required package: survival\n\nx <- Boston[ , 1:12]\ny <- Boston [, \"medv\"]\n\n# train and test partitions\nxtrain <- x[train, ]\nytrain <- y[train]\nxtest <- x[-train, ]\nytest <- y[-train]\n\nset.seed(1)\nbartfit <- gbart(xtrain, ytrain, x.test = xtest )\n\n*****Calling gbart: type=1\n*****Data:\ndata:n,p,np: 253, 12, 253\ny1,yn: 0.213439, -5.486561\nx1,x[n*p]: 0.109590, 20.080000\nxp1,xp[np*p]: 0.027310, 7.880000\n*****Number of Trees: 200\n*****Number of Cut Points: 100 ... 100\n*****burn,nd,thin: 100,1000,1\n*****Prior:beta,alpha,tau,nu,lambda,offset: 2,0.95,0.795495,3,3.71636,21.7866\n*****sigma: 4.367914\n*****w (weights): 1.000000 ... 1.000000\n*****Dirichlet:sparse,theta,omega,a,b,rho,augment: 0,0,1,0.5,1,12,0\n*****printevery: 100\n\nMCMC\ndone 0 (out of 1100)\ndone 100 (out of 1100)\ndone 200 (out of 1100)\ndone 300 (out of 1100)\ndone 400 (out of 1100)\ndone 500 (out of 1100)\ndone 600 (out of 1100)\ndone 700 (out of 1100)\ndone 800 (out of 1100)\ndone 900 (out of 1100)\ndone 1000 (out of 1100)\ntime: 2s\ntrcnt,tecnt: 1000,1000\n\n\n\n# compute the test error\nyhat.bart <- bartfit$yhat.test.mean\nmean((ytest - yhat.bart )^2)\n\n[1] 15.94718\n\n\nOn this data set, the test error of {BART} is lower than the test error of random forests and boosting.\nNow we can check how many times each variable appeared in the collection of trees.\n\nord <- order(bartfit$varcount.mean, decreasing = T)\nbartfit$varcount.mean[ord]\n\n    nox   lstat     tax     rad      rm   indus    chas ptratio     age      zn \n 22.952  21.329  21.250  20.781  19.890  19.825  19.051  18.976  18.274  15.952 \n    dis    crim \n 14.457  11.007"
  }
]